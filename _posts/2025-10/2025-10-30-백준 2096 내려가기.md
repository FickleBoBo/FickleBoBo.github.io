---
title: "[백준] 2096번 - 내려가기 [Java]"
date: 2025-10-30
categories: [PS, BaekJoon]
tags: [다이나믹 프로그래밍, 토글링]
toc: true
math: true
image: /assets/posts/2025-10/백준%202096%20내려가기/thumbnail.png
---

[문제 링크](https://www.acmicpc.net/problem/2096)

![](/assets/posts/2025-10/백준%202096%20내려가기/photo1.png)
![](/assets/posts/2025-10/백준%202096%20내려가기/photo2.png)

---

## 문제 풀이

내려가기 게임에서 이동 가능한 경로는 현재 위치에서 바로 아래 칸이거나 대각선 칸으로만 이동할 수 있다. `0`번 인덱스 위치에서는 `0`, `1`번 인덱스로, `1`번 인덱스 위치에서는 `0`, `1`, `2`번 인덱스로, `2`번 인덱스 위치에서는 `1`, `2`번 인덱스로 이동할 수 있다. 이때 얻을 수 있는 점수의 최댓값과 최솟값을 구해야 하며 풀이 언어에 따라 다르지만 `4MB`의 메모리 제한이 있다. 메모리 효율적으로 이 문제를 해결하는데는 다이나믹 프로그래밍과 토글링 기법을 활용하면 된다.

다이나믹 프로그래밍의 경우 현재 위치로 올 수 있었던 이전 위치까지의 점수의 최댓값, 최솟값에서 현재 위치의 값을 더하는 것을 반복하는 것으로 점화식을 세울 수 있다. 예제 입력 1에 대해서 아래와 같은 과정을 통해 dp 테이블을 만들 수 있다.

왼쪽은 주어진 입력, 오른쪽은 동일한 크기의 dp 테이블이다.

![](/assets/posts/2025-10/백준%202096%20내려가기/photo01.drawio.svg)

첫 행은 이전에 방문한 곳이 없으므로 현재 칸을 방문할 때 점수와 동일하다.

![](/assets/posts/2025-10/백준%202096%20내려가기/photo02.drawio.svg)

두 번째 행부터는 이전에 올 수 있었던 점수의 최댓값, 최솟값에서 현재 칸의 점수를 더하면 된다. 이전에 올 수 있었던 점수의 최댓값, 최솟값은 dp 테이블에 기록하고 있었으므로 해당 정보를 활용한다. 아래부터는 최댓값을 구하는 예시다.

![](/assets/posts/2025-10/백준%202096%20내려가기/photo03.drawio.svg)
![](/assets/posts/2025-10/백준%202096%20내려가기/photo04.drawio.svg)
![](/assets/posts/2025-10/백준%202096%20내려가기/photo05.drawio.svg)
![](/assets/posts/2025-10/백준%202096%20내려가기/photo06.drawio.svg)
![](/assets/posts/2025-10/백준%202096%20내려가기/photo07.drawio.svg)
![](/assets/posts/2025-10/백준%202096%20내려가기/photo08.drawio.svg)

최솟값 역시 동일하게 구하면 된다.

여기서 dp 테이블의 갱신에 이전 행의 정보만 필요하다는 점에서 토글링 기법을 활용하면 메모리를 훨씬 더 절약할 수 있다.

임시 공간에 현재 갱신될 정보를 저장한 후 dp에 반영해주는 것을 반복하면 된다.

---

## 코드

### 1. 슬라이딩 윈도우 [Java]

최댓값, 최솟값 dp는 전부 1차원 배열을 활용했고 임시 저장용 배열 `tmp`를 활용했다. 입력 값이 1회성 정보이므로 입력 받으면서 바로 처리를 해서 입력 값을 저장할 메모리도 절약했다.

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        int N = Integer.parseInt(br.readLine());

        int[] maxDp = new int[3];
        int[] minDp = new int[3];
        int[] tmp = new int[3];  // 계산값 임시저장용 배열

        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            int x1 = Integer.parseInt(st.nextToken());
            int x2 = Integer.parseInt(st.nextToken());
            int x3 = Integer.parseInt(st.nextToken());

            // 최대 점수 계산
            tmp[0] = Math.max(maxDp[0], maxDp[1]) + x1;
            tmp[1] = Math.max(maxDp[0], Math.max(maxDp[1], maxDp[2])) + x2;
            tmp[2] = Math.max(maxDp[1], maxDp[2]) + x3;

            maxDp[0] = tmp[0];
            maxDp[1] = tmp[1];
            maxDp[2] = tmp[2];

            // 최소 점수 계산
            tmp[0] = Math.min(minDp[0], minDp[1]) + x1;
            tmp[1] = Math.min(minDp[0], Math.min(minDp[1], minDp[2])) + x2;
            tmp[2] = Math.min(minDp[1], minDp[2]) + x3;

            minDp[0] = tmp[0];
            minDp[1] = tmp[1];
            minDp[2] = tmp[2];
        }

        int max = Math.max(maxDp[0], Math.max(maxDp[1], maxDp[2]));
        int min = Math.min(minDp[0], Math.min(minDp[1], minDp[2]));

        System.out.println(max + " " + min);
    }
}
```

---

## 풀이 정보

### 1. 슬라이딩 윈도우 [Java]

- 20 min

![](/assets/posts/2025-10/백준%202096%20내려가기/photo3.png)

---
