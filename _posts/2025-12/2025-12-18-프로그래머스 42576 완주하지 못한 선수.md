---
title: "[프로그래머스] 42576번 - 완주하지 못한 선수 [Java][C++]"
date: 2025-12-18
categories: [PS, Programmers]
tags: [해시를 사용한 집합과 맵]
toc: true
math: true
---

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42576)

---

## 문제 설명

수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다.

마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.

---

## 제한 사항

- 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.
- completion의 길이는 participant의 길이보다 1 작습니다.
- 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.
- 참가자 중에는 동명이인이 있을 수 있습니다.

---

## 입출력 예

| participant                                       | completion                               | return   |
| ------------------------------------------------- | ---------------------------------------- | -------- |
| ["leo", "kiki", "eden"]                           | ["eden", "kiki"]                         | "leo"    |
| ["marina", "josipa", "nikola", "vinko", "filipa"] | ["josipa", "filipa", "marina", "nikola"] | "vinko"  |
| ["mislav", "stanko", "mislav", "ana"]             | ["stanko", "ana", "mislav"]              | "mislav" |

---

## 입출력 예 설명

### 예제 #1

"leo"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

### 예제 #2

"vinko"는 참여자 명단에는 있지만, 완주자 명단에는 없기 때문에 완주하지 못했습니다.

### 예제 #3

"mislav"는 참여자 명단에는 두 명이 있지만, 완주자 명단에는 한 명밖에 없기 때문에 한명은 완주하지 못했습니다.

---

## 1. 문제 풀이

`participant` 에서 `completion` 를 뺀 한 명의 선수를 찾는 문제로 해시맵 자료구조를 활용하면 해결할 수 있다. 이름이 중복인 선수가 없다면 해시셋을 사용하면 되지만 이름이 중복될 수 있기에 `key` 에 선수 이름, `value` 에 해당 선수의 수를 저장한 해시맵 자료구조로 참여한 선수 정보를 먼저 저장 후 완주한 선수 정보를 갱신해줬다. 이러면 해시맵에는 `value` 가 $1$ 인 선수 한 명이 유일하게 존재하게 된다.

---

## 2. 코드

### 1. 해시를 사용한 집합과 맵 [Java]

```java
import java.util.*;

class Solution {
    public String solution(String[] participant, String[] completion) {
        Map<String, Integer> map = new HashMap<>();

        for (String p : participant) {
            map.put(p, map.getOrDefault(p, 0) + 1);
        }

        for (String c : completion) {
            map.put(c, map.get(c) - 1);
        }

        String answer = "";
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            if (entry.getValue() == 1) {
                answer = entry.getKey();
                break;
            }
        }

        return answer;
    }
}
```

### 2. 해시를 사용한 집합과 맵 [C++]

```c++
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

string solution(vector<string> participant, vector<string> completion) {
    unordered_map<string, int> mp;

    for (string& s : participant) {
        mp[s]++;
    }

    for (string& c : completion) {
        mp[c]--;
    }

    string ans;
    for (auto& [key, value] : mp) {
        if (value == 1) {
            ans = key;
            break;
        }
    }

    return ans;
}
```

---

## 3. 풀이 정보

### 1. 해시를 사용한 집합과 맵 [Java]

| 정확성 테스트                     |
| --------------------------------- |
| 테스트 1 〉 통과 (0.07ms, 84.1MB) |
| 테스트 2 〉 통과 (0.08ms, 86MB)   |
| 테스트 3 〉 통과 (0.76ms, 75.9MB) |
| 테스트 4 〉 통과 (1.04ms, 82MB)   |
| 테스트 5 〉 통과 (0.75ms, 71.7MB) |
| 테스트 6 〉 통과 (0.05ms, 85.7MB) |
| 테스트 7 〉 통과 (0.06ms, 84.7MB) |

| 효율성 테스트                      |
| ---------------------------------- |
| 테스트 1 〉 통과 (36.26ms, 85.1MB) |
| 테스트 2 〉 통과 (62.21ms, 90.2MB) |
| 테스트 3 〉 통과 (64.16ms, 96.4MB) |
| 테스트 4 〉 통과 (85.20ms, 97.6MB) |
| 테스트 5 〉 통과 (75.24ms, 97.8MB) |

### 2. 해시를 사용한 집합과 맵 [C++]

| 정확성 테스트                     |
| --------------------------------- |
| 테스트 1 〉 통과 (0.01ms, 3.66MB) |
| 테스트 2 〉 통과 (0.01ms, 4.12MB) |
| 테스트 3 〉 통과 (0.16ms, 4.18MB) |
| 테스트 4 〉 통과 (0.38ms, 4.13MB) |
| 테스트 5 〉 통과 (0.31ms, 4.13MB) |
| 테스트 6 〉 통과 (0.01ms, 4.18MB) |
| 테스트 7 〉 통과 (0.01ms, 4.19MB) |

| 효율성 테스트                      |
| ---------------------------------- |
| 테스트 1 〉 통과 (17.88ms, 17.7MB) |
| 테스트 2 〉 통과 (25.03ms, 25.4MB) |
| 테스트 3 〉 통과 (31.42ms, 30.1MB) |
| 테스트 4 〉 통과 (36.19ms, 32.5MB) |
| 테스트 5 〉 통과 (33.46ms, 32.5MB) |

---
