---
title: "[백준] 5582번 - 공통 부분 문자열 [Java]"
date: 2025-11-05
categories: [알고리즘, 백준]
tags: [문자열, 다이나믹 프로그래밍, LCS]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/5582)

![](/assets/posts/2025-11/백준%205582%20공통%20부분%20문자열/photo1.png)
![](/assets/posts/2025-11/백준%205582%20공통%20부분%20문자열/photo2.png)

---

## 문제 풀이

두 문자열의 가장 긴 공통 부분 문자열을 찾는 문제로 LCS를 활용하면 해결할 수 있다. 일반적인 LCS는 Longest Common Subsequence로 서로 떨어진 부분 문자열도 포함이 되지만 여기서는 딱 붙어 있는 경우를 찾아야 한다. 기존 다이나믹 프로그래밍을 활용한 LCS는 문자가 서로 같으면 +1을 하고 아니면 인접한 최댓값으로 갱신해서 떨어진 경우를 포함했지만, 이 경우에는 인접한 최댓값으로 갱신을 안하면 된다.

$$
DP[i][j] =
\begin{cases}
0 & \text{if } i = 0 \text{ or } j = 0 \\\\
DP[i-1][j-1] + 1 & \text{if } A[i] = B[j] \\\\
0 & \text{otherwise}
\end{cases}
$$

다만 이 경우 dp 배열의 가장 마지막 값으로 LCS의 길이를 구하는 것이 아니라 중간에 LCS의 길이가 나왔다가 다시 사라지므로 최댓값을 따로 갱신하며 들고 있어야 한다.

---

## 코드

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        char[] str1 = br.readLine().toCharArray();
        char[] str2 = br.readLine().toCharArray();
        int N = str1.length;
        int M = str2.length;

        int[][] dp = new int[1 + N][1 + M];
        int max = 0;

        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= M; j++) {
                if (str1[i - 1] == str2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                    max = Math.max(max, dp[i][j]);
                }
            }
        }

        System.out.println(max);
    }
}
```

---

## 풀이 정보

- 13 min

![](/assets/posts/2025-11/백준%205582%20공통%20부분%20문자열/photo3.png)

---

## 리뷰

떨어진 부분 문자열은 포함시키지 않는 유형은 처음 봐서 신선했다.

---
