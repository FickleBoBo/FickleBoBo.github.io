---
title: "[백준] 1064번 - 평행사변형 [Java]"
date: 2025-11-20
categories: [PS, BaekJoon]
tags: [수학, 기하학, 피타고라스 정리]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/1064)

![](/assets/posts/2025-11/백준%201064%20평행사변형/photo1.png)
![](/assets/posts/2025-11/백준%201064%20평행사변형/photo2.png)

---

## 문제 풀이

서로 다른 세 점이 주어졌을 때, 적절한 점 `D`로 평행사변형을 만들 수 없으면 `-1`을 출력하고 만들 수 있으면 만들 수 있는 평행사변형 중 가장 큰 둘레의 길이와 가장 작은 둘레의 길이의 차를 출력해야 하는 문제다.

평행사변형을 만들 수 없는 경우는 세 점이 일직선 상에 위치하는 경우로 세 점의 좌표가 $(x_A, y_A)$, $(x_B, y_B)$, $(x_C, y_C)$일 경우 $\dfrac{y_B-y_A}{x_B-x_A} = \dfrac{y_C-y_A}{x_C-x_A}$로 기울기를 비교하면 일직선 상에 위치하는지 알 수 있다. 이때 x좌표가 일치할 수도 있고 나눗셈의 경우 나머지가 버림처리 되며 실수 타입은 부동소수점 오차가 생길 수 있기 때문에 $(y_B-y_A)\cdot(x_C-x_A) = (y_C-y_A)\cdot(x_B-x_A)$로 계산했다.

세 점이 일직선 상에 위치하지 않을 경우 세 점으로 만들 수 있는 삼각형의 각 변마다 해당 변을 대각선으로 갖는 평행사변형을 만들 수 있는데 이 평행사변형의 둘레의 길이는 다른 두 변의 길이의 합의 두 배임을 이용하면 된다.

아래 그림과 같이 둘레의 길이가 $2 \cdot (a + b)$, $2 \cdot (b + c)$, $2 \cdot (c + a)$인 3개의 평행사변형을 만들 수 있다.(직각, 둔각 삼각형도 동일하다.)

![](/assets/posts/2025-11/백준%201064%20평행사변형/photo01.drawio.svg)
![](/assets/posts/2025-11/백준%201064%20평행사변형/photo02.drawio.svg)
![](/assets/posts/2025-11/백준%201064%20평행사변형/photo03.drawio.svg)

이때 가장 큰 둘레의 길이와 가장 작은 둘레의 길이의 차는 $2 \cdot (가장\ 긴\ 변 - 가장\ 짧은\ 변)$이 됨을 이용하면 된다.

---

## 코드

### 1. 피타고라스 정리 [Java]

세 점이 일직선 상에 위치하는지 먼저 판단 후 일직선 상에 위치하지 않으면 세 변의 길이를 구해서 배열에 저장한 후 정렬하여 가장 긴 변과 가장 짧은 변을 구했다. 변의 길이는 두 점의 거리로 피타고라스 정리로 구할 수 있다.

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int xa = Integer.parseInt(st.nextToken());
        int ya = Integer.parseInt(st.nextToken());
        int xb = Integer.parseInt(st.nextToken());
        int yb = Integer.parseInt(st.nextToken());
        int xc = Integer.parseInt(st.nextToken());
        int yc = Integer.parseInt(st.nextToken());

        if ((yb - ya) * (xc - xa) == (yc - ya) * (xb - xa)) {
            System.out.println(-1);
        } else {
            double[] sides = {distance(xa, ya, xb, yb), distance(xb, yb, xc, yc), distance(xc, yc, xa, ya)};
            Arrays.sort(sides);

            System.out.println(2 * (sides[2] - sides[0]));
        }
    }

    private static double distance(double x1, double y1, double x2, double y2) {
        return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
    }
}
```

---

## 풀이 정보

### 1. 피타고라스 정리 [Java]

- 18 min

![](/assets/posts/2025-11/백준%201064%20평행사변형/photo3.png)

---
