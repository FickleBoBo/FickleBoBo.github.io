---
title: "[백준] 10982번 - 행운쿠키 제작소 [Java]"
date: 2025-11-15
categories: [PS, BaekJoon]
tags: [다이나믹 프로그래밍, 배낭 문제, 토글링]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/10982)

![](/assets/posts/2025-11/백준%2010982%20행운쿠키%20제작소/photo1.png)
![](/assets/posts/2025-11/백준%2010982%20행운쿠키%20제작소/photo2.png)

---

## 문제 풀이

[백준 17528번 - Two Machines]({% post_url 2025-11/2025-11-15-백준 17528 Two Machines %}) 문제와 거의 유사한 문제로 테스트 케이스 단위로 처리해야하는 문제다. `N`이 최대 `1,000`이고 한 개의 오븐에서 구워지는데 걸리는 시간의 합의 최대가 `1,000 * 100 = 100,000`이어서 `1,000 * 100,000 = 100,000,000`인 2차원 배열 풀이는 메모리 초과가 발생한다.(`int`형이면 약 400MB)

2차원 배열을 활용한 다이나믹 프로그래밍이 이전 행의 정보만 필요하다는 점을 활용한 토글링을 적용하거나 아예 1차원 배열을 활용한 다이나믹 프로그래밍으로 해결할 수 있다.

---

## 코드

### Bottom-Up 토글링 dp [Java]

두 행을 갖는 dp 테이블을 만들고 `prev`와 `cur` 변수를 `0`, `1`로 초기화 해줬다. 이후 `prev`행을 기반으로 `cur`행을 갱신하고 XOR 연산으로 `prev`와 `cur`을 바꾸는 과정을 반복했다. 최종 결과가 `cur`행에 저장된 후 토글링이 또 일어나므로 `prev`를 통해 참조해야 최종 결과값이 나온다.

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();
        StringTokenizer st;

        int T = Integer.parseInt(br.readLine());
        for (int tc = 1; tc <= T; tc++) {
            int N = Integer.parseInt(br.readLine());

            int[] A = new int[N];
            int[] B = new int[N];
            int sumA = 0;
            for (int i = 0; i < N; i++) {
                st = new StringTokenizer(br.readLine());
                sumA += A[i] = Integer.parseInt(st.nextToken());
                B[i] = Integer.parseInt(st.nextToken());
            }

            int[][] dp = new int[2][1 + sumA];  // 토글링 dp
            int prev = 0;
            int cur = 1;
            for (int i = 0; i < N; i++) {
                int a = A[i];
                int b = B[i];

                for (int j = 0; j <= sumA; j++) {
                    if (j < a) {
                        dp[cur][j] = dp[prev][j] + b;
                    } else {
                        dp[cur][j] = Math.min(dp[prev][j - a], dp[prev][j] + b);
                    }
                }

                // 토글링
                prev ^= 1;
                cur ^= 1;
            }

            int min = Integer.MAX_VALUE;
            for (int j = 0; j <= sumA; j++) {
                min = Math.min(min, Math.max(j, dp[prev][j]));  // 토글링 때문에 최신값이 prev에 있음
            }

            sb.append(min).append('\n');
        }

        bw.write(sb.toString());
        bw.flush();
    }
}
```

### Bottom-Up 1차원 dp [Java]

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();
        StringTokenizer st;

        int T = Integer.parseInt(br.readLine());
        for (int tc = 1; tc <= T; tc++) {
            int N = Integer.parseInt(br.readLine());

            int[] A = new int[N];
            int[] B = new int[N];
            int sumA = 0;
            for (int i = 0; i < N; i++) {
                st = new StringTokenizer(br.readLine());
                sumA += A[i] = Integer.parseInt(st.nextToken());
                B[i] = Integer.parseInt(st.nextToken());
            }

            int[] dp = new int[1 + sumA];
            for (int i = 0; i < N; i++) {
                int a = A[i];
                int b = B[i];

                for (int j = sumA; j >= 0; j--) {
                    if (j < a) {
                        dp[j] += b;
                    } else {
                        dp[j] = Math.min(dp[j - a], dp[j] + b);
                    }
                }
            }

            int min = Integer.MAX_VALUE;
            for (int j = 0; j <= sumA; j++) {
                min = Math.min(min, Math.max(j, dp[j]));
            }

            sb.append(min).append('\n');
        }

        bw.write(sb.toString());
        bw.flush();
    }
}
```

---

## 풀이 정보

### Bottom-Up 토글링 dp [Java]

- 52 min

![](/assets/posts/2025-11/백준%2010982%20행운쿠키%20제작소/photo3.png)

### Bottom-Up 1차원 dp [Java]

- 6 min

![](/assets/posts/2025-11/백준%2010982%20행운쿠키%20제작소/photo4.png)

---
