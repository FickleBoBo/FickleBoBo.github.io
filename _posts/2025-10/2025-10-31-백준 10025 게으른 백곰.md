---
title: "[백준] 10025번 - 게으른 백곰 [Java]"
date: 2025-10-31
categories: [알고리즘, 백준]
tags: [누적합, 투 포인터 알고리즘, 슬라이딩 윈도우]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/10025)

![](/assets/posts/2025-10/백준%2010025%20게으른%20백곰/photo1.png)
![](/assets/posts/2025-10/백준%2010025%20게으른%20백곰/photo2.png)

---

## 문제 풀이

얼음 양동이들의 좌표와 얼음의 양이 주어져 있고 백곰이 좌우로 `K`만큼 떨어진 양동이에 닿을 수 있을 때 최적의 자리에서 얼음의 합의 최댓값을 구해야 하는 문제다. 누적합, 투 포인터, 슬라이딩 윈도우 3가지 방식으로 모두 풀이가 가능하다. 백곰은 양동이가 있는 좌표에도 있을 수 있으며 좌우로 `K`만큼 떨어진 양동이도 잡을 수 있으므로 잡을 수 있는 범위의 크기는 `2 * K + 1`이다.

### 1. 누적합

주어진 양동이의 좌표를 인덱스로 얼음의 양을 값으로 하는 1차원 배열을 만든 후 해당 배열로 누적합 배열을 만들면 된다. 이후 누적합 배열에서 두 값의 차가 구간의 합이 된다는 점을 활용하면 된다. 이때 닿을 수 있는 범위가 배열의 인덱스를 넘어갈 수 있어서 먼저 예외 처리를 해주었다.

### 2. 투 포인터

주어진 입력값을 2차원 배열로 받았다. 이후 양동이의 좌표에 대해 정렬해주면 탐색할 준비가 됐다. 탐색의 경우 두 포인터의 값의 차가 현재 닿을 수 있는 범위가 되므로 두 포인터의 값의 차가 백곰이 닿을 수 있는 범위보다 크면 왼쪽 포인터를 이동하고 작거나 같으면 오른쪽 포인터를 이동시키며 얼음의 양을 계산하면 된다.

### 3. 슬라이딩 윈도우

주어진 양동이의 좌표를 인덱스로 얼음의 양을 값으로 하는 1차원 배열을 만든 후 슬라이딩 윈도우를 적용하면 된다. 이때 닿을 수 있는 범위가 배열의 인덱스를 넘어갈 수 있어서 먼저 예외 처리를 해주었다.

---

## 코드

### 1. 누적합

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        int[][] input = new int[N][2];  // 양동이의 얼음의 양과 좌표를 임시 저장
        int maxLen = 0;  // 양동이의 좌표의 최댓값
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            input[i][0] = Integer.parseInt(st.nextToken());
            input[i][1] = Integer.parseInt(st.nextToken());
            maxLen = Math.max(maxLen, input[i][1]) + 1;
        }

        // 인덱스에 양동이의 좌표, 값에 양동이의 얼음의 양 저장
        int[] arr = new int[maxLen];
        for (int i = 0; i < N; i++) {
            arr[input[i][1]] = input[i][0];
        }

        // 앞에 패딩을 한 칸 준 누적합 배열 계산
        int[] prefixSum = new int[1 + maxLen];
        for (int i = 1; i <= maxLen; i++) {
            prefixSum[i] = prefixSum[i - 1] + arr[i - 1];
        }

        // 닿을 수 있는 범위
        int size = 2 * K + 1;

        // 모든 양동이에 닿을 수 있으면 모든 양동이의 얼음의 양의 합을 출력하고 리턴
        if (size > maxLen) {
            System.out.println(prefixSum[maxLen]);
            return;
        }

        // 누적합 배열에서 구간을 이동하며 최댓값 계산
        int max = 0;
        for (int i = 0; i <= maxLen - size; i++) {
            max = Math.max(max, prefixSum[i + size] - prefixSum[i]);
        }

        System.out.println(max);
    }
}
```

### 2. 투 포인터

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        int[][] input = new int[N][2];  // 양동이의 얼음의 양과 좌표를 임시 저장
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            input[i][0] = Integer.parseInt(st.nextToken());
            input[i][1] = Integer.parseInt(st.nextToken());
        }
        // 양동이의 좌표를 기준으로 정렬
        Arrays.sort(input, ((o1, o2) -> Integer.compare(o1[1], o2[1])));

        int left = 0;
        int right = 0;
        int sum = 0;
        int max = 0;

        while (true) {
            // 더 잡을 수 있으면 오른쪽 포인터를 이동하며 더 잡을 수 없으면 왼쪽 포인터를 이동
            if (input[right][1] - input[left][1] > (2 * K + 1)) {
                sum -= input[left++][0];
            } else {
                sum += input[right++][0];
                max = Math.max(max, sum);
            }

            if (right == N) break;
        }

        System.out.println(max);
    }
}
```

### 3. 슬라이딩 윈도우

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int K = Integer.parseInt(st.nextToken());

        int[][] input = new int[N][2];  // 양동이의 얼음의 양과 좌표를 임시 저장
        int maxLen = 0;  // 양동이의 좌표의 최댓값
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            input[i][0] = Integer.parseInt(st.nextToken());
            input[i][1] = Integer.parseInt(st.nextToken());
            maxLen = Math.max(maxLen, input[i][1]) + 1;
        }

        // 인덱스에 양동이의 좌표, 값에 양동이의 얼음의 양 저장
        int[] arr = new int[maxLen];
        for (int i = 0; i < N; i++) {
            arr[input[i][1]] = input[i][0];
        }

        // 윈도우의 크기
        int windowSize = 2 * K + 1;

        // 윈도우가 좌표의 최댓값보다 크면 모든 양동이에 닿을 수 있으므로 모든 양동이의 얼음의 합을 출력하고 리턴
        if (windowSize > maxLen) {
            int sum = 0;

            for (int n : arr) {
                sum += n;
            }

            System.out.println(sum);
            return;
        }

        // 초기 윈도우 내 얼음의 합 계산
        int sum = 0;
        for (int i = 0; i < windowSize; i++) {
            sum += arr[i];
        }

        // 윈도우를 이동하며 얼음의 합의 최댓값 계산
        int max = sum;
        for (int i = 0; i < maxLen - windowSize; i++) {
            sum = sum - arr[i] + arr[i + windowSize];
            max = Math.max(max, sum);
        }

        System.out.println(max);
    }
}
```

---

## 풀이 정보

### 1. 누적합

- 11 min

![](/assets/posts/2025-10/백준%2010025%20게으른%20백곰/photo3.png)

### 2. 투 포인터

- 19 min

![](/assets/posts/2025-10/백준%2010025%20게으른%20백곰/photo4.png)

### 3. 슬라이딩 윈도우

- 23 min

![](/assets/posts/2025-10/백준%2010025%20게으른%20백곰/photo5.png)

---

## 리뷰

양동이가 있는 좌표만 활용하는 투 포인터가 의외로 느려서 약간 특이하게 느껴졌다. 정렬 비용이 제법 많이 들어서 그런 것 같았다.

---
