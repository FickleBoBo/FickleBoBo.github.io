---
title: "[Item-28] 배열보다는 리스트를 사용하라"
date: 2025-10-20
categories: [Java, Effective Java 3/E]
tags: [Effective Java 3/E]
toc: true
math: true
image: /assets/posts/2025-10/Item-28%20배열보다는%20리스트를%20사용하라/thumbnail.jpg
---

## 공변(Covariant), 불공변(Invariant), 반공변(Contravariant)

Java에서 배열은 공변이다. `Sub`가 `Super`의 하위 타입이라면 `Sub[]`는 `Super[]`의 하위 타입이 된다.

아래처럼 `Integer[]`는 `Object[]`의 하위 타입이 될 수 있으며 타입은 `Object[]`지만 실제 인스턴스는 `Integer[]`여서 `String` 타입 객체를 담을 수 없으니 예외가 발생했다. 해당 문제는 컴파일 타임에 알 수 없다.

```java
public class ArrayCovariantTestMain {

    public static void main(String[] args) {
        Integer[] integers = new Integer[1];
        Object[] objects = integers;

        objects[0] = "hello";
        // ArrayStoreException 발생
    }
}
```

Java에서 제네릭은 기본적으로 불공변이다. `Type1`이 `Type2`의 하위 타입이라도 `List<Type1>`은 `List<Type2>`의 하위 타입이 아니다. 물론 상위 타입도 아니다.

```java
public class GenericCovariantTestMain {

    public static void main(String[] args) {
        List<Integer> integerList = new ArrayList<>();
        List<Object> objectList = integerList;  // 컴파일 실패
    }
}
```

위 코드들처럼 배열과 리스트는 가변 길이 여부 외에도 이런 차이가 있다.

제네릭과 배열을 함께 쓸 경우 타입 안전성 문제가 생길 수 있다. 아래는 흔히 인접 리스트를 구할 때 제네릭 배열을 활용하는 코드를 작성하면 IDE에서 노란줄로 경고가 나오는데 아래 같은 타입 안전성 문제가 발생할 수 있기 때문이다.

```java
public class GenericArrayTestMain {

    public static void main(String[] args) {
        List<Integer>[] adj = new ArrayList[1];
        // 실제 인스턴스는 로 타입 ArrayList인 배열이 됨

        List<Object> objectList = new ArrayList<>();
        objectList.add("hello");
        // "hello" 하나를 원소로 갖는 List<Object>

        Object[] objectArray = adj;
        // 배열은 공변이라서 리스트 배열을 오브젝트 배열에 대입 가능

        objectArray[0] = objectList;
        // 오브젝트 배열에 objectList 대입

        Integer integer = adj[0].get(0);
        // Integer 타입 원소를 꺼낼 것으로 예상했지만 "hello"가 들어있어서 ClassCastException 발생
    }
}
```

제네릭에서도 와일드 카드를 활용하면 공변과 반공변을 표현할 수 있다. `extends` 키워드로 하위 타입을, `super` 키워드로 상위 타입을 표현할 수 있다.

아래처럼 간단한 동물 인터페이스와 개, 고양이 클래스를 만들어 준 후

```java
public interface Animal {

    void bark();
}

public class Dog implements Animal {

    public String name;

    public Dog(String name) {
        this.name = name;
    }

    @Override
    public void bark() {
        System.out.println(name + " 멍멍");
    }

    @Override
    public String toString() {
        return "Dog{" +
                "name='" + name + '\'' +
                '}';
    }
}

public class Cat implements Animal {

    public String name;

    public Cat(String name) {
        this.name = name;
    }

    @Override
    public void bark() {
        System.out.println(name + " 냐옹");
    }

    @Override
    public String toString() {
        return "Cat{" +
                "name='" + name + '\'' +
                '}';
    }
}
```

아래처럼 `Dog`를 타입 파라미터로 갖는 리스트, `Cat`을 타입 파라미터로 갖는 리스트를 선언했다. `addAll` 메서드는 두 개의 파라미터를 갖는데 첫 번째 파라미터의 리스트의 원소를 두 번째 파라미터의 리스트로 복사해주는 메서드다. 이때 첫번째 파라미터의 리스트에는 `extends` 키워드를 활용해서 `Animal` 타입과 그 하위 타입을 포함하도록 했고, 두번째 파라미터의 리스트에는 `super` 키워드를 활용해서 `Animal` 타입과 그 상위 타입을 포함하도록 했다.

이렇게 구현하면 `Animal`과 그 하위 타입을 파라미터로 갖는 리스트를 `Animal`과 그 상위 타입을 파라미터로 갖는 리스트에 복사할 수 있다.

```java
public class WildcardTestMain {

    public static void main(String[] args) {
        List<Dog> dogs = List.of(new Dog("개1"), new Dog("개2"), new Dog("개3"));
        List<Cat> cats = List.of(new Cat("고양이1"), new Cat("고양이2"), new Cat("고양이3"));

        List<Animal> animals = new ArrayList<>();
        addAll(dogs, animals);
        addAll(cats, animals);

        barkAll(animals);

        List<Object> objectList = new ArrayList<>();
        addAll(dogs, objectList);
        addAll(cats, objectList);

        for (Object object : objectList) {
            System.out.println(object);
        }
    }

    private static void barkAll(List<Animal> list) {
        for (Animal animal : list) {
            animal.bark();
        }
    }

    private static void addAll(List<? extends Animal> list, List<? super Animal> list2) {
        for (Animal animal : list) {
            list2.add(animal);
        }
    }
}
```

---

## 컬렉션 프레임워크의 와일드카드

무심코 사용하는 컬렉션 프레임워크에도 와일드카드를 활용한 다양한 메서드들이 있고 이를 통해 공변, 반공변에 대해 표현하고 있다.

생성자에 컬렉션을 넘기면 해당 파라미터로 컬렉션을 초기화해주는 생성자는(ArrayList) [public ArrayList(Collection<? extends E> c)](<https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/ArrayList.html#%3Cinit%3E(java.util.Collection)>) 이런 시그니처를 가지고 있는데 이를 통해 타입 파라미터가 하위 타입인 경우 현재 타입 파라미터로 컬렉션을 초기화할 수 있다.

아래 코드처럼 `List<Dog>` 제네릭 타입 리스트로 `List<Animal>` 제네릭 타입 리스트를 생성할 수 있다.

```java
    public static void main(String[] args) {
        List<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog("개1"));
        dogs.add(new Dog("개3"));
        dogs.add(new Dog("개4"));
        dogs.add(new Dog("개2"));
        dogs.add(new Dog("개5"));

        List<Animal> animals = new ArrayList<>(dogs);
        for (Animal animal : animals) {
            System.out.println(animal);
        }
        // Dog{name='개1'}
        // Dog{name='개3'}
        // Dog{name='개4'}
        // Dog{name='개2'}
        // Dog{name='개5'}
    }
```

리스트를 정렬할 때 사용하는 메서드인 [default void sort(Comparator<? super E> c)](<https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/List.html#sort(java.util.Comparator)>) 이런 시그니처를 가지고 있는데 이를 통해 상위 타입의 정렬 기준도 허용하고 있다.

아래처럼 동물의 정렬 기준을 설정하면 `List<Dog>`도 해당 기준으로 정렬할 수 있다.

```java
    public static void main(String[] args) {
        List<Dog> dogs = new ArrayList<>();
        dogs.add(new Dog("개1"));
        dogs.add(new Dog("개3"));
        dogs.add(new Dog("개4"));
        dogs.add(new Dog("개2"));
        dogs.add(new Dog("개5"));

        Comparator<Animal> animalComparator = new Comparator<>() {
            @Override
            public int compare(Animal o1, Animal o2) {
                return -1;
            }
        };

        dogs.sort(animalComparator);
        for (Dog dog : dogs) {
            System.out.println(dog);
        }
        // Dog{name='개5'}
        // Dog{name='개2'}
        // Dog{name='개4'}
        // Dog{name='개3'}
        // Dog{name='개1'}
    }
```

---
