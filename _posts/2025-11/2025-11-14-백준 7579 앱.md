---
title: "[백준] 7579번 - 앱 [Java]"
date: 2025-11-14
categories: [PS, BaekJoon]
tags: [다이나믹 프로그래밍, 배낭 문제]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/7579)

![](/assets/posts/2025-11/백준%207579%20앱/photo1.png)
![](/assets/posts/2025-11/백준%207579%20앱/photo2.png)

---

## 문제 풀이

활성화된 앱들이 주어져 있고 각 앱은 비활성화 했을 때 비용 `c`와 확보할 수 있는 메모리 `m`을 가지고 있다. 이때 `M` 이상의 메모리를 확보할 때 최소 비용을 알아내야 하는 문제다. 이는 비용을 무게, 확보할 수 있는 메모리를 가치로 간주하는 0-1 배낭 문제로 해결할 수 있다. 각 앱을 비활성화하느냐 마느냐를 0-1 배낭 문제로 쭉 계산한 후 비용이 `0`일 때 확보할 수 있는 메모리부터 쭉 탐색해서 확보할 수 있는 메모리가 `M` 이상이면 종료하면 된다.

비활성화 했을 때 비용이 `0`일 수 있음에 주의해야 한다.

---

## 코드

### 1. Bottom-Up 2차원 dp [Java]

모든 앱을 비활성화 했을 때 비용 `sum`을 구해서 이를 dp 테이블의 열의 크기로 설정해줬다. 배낭에 앱을 담을 때 비용이 `0`일 수 있어서 `j = 0`이 단순한 패딩이 아니라 실제로 의미있는 값임에 주의해야 한다.

`M`의 경우 모든 앱을 비활성화 했을 때 확보할 수 있는 메모리보다 작거나 같으므로 마지막 행을 탐색하면 반드시 `M` 이상인 순간이 나온다.

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        int[] mArr = new int[1 + N];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= N; i++) {
            mArr[i] = Integer.parseInt(st.nextToken());
        }

        int[] cArr = new int[1 + N];
        int sum = 0;
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= N; i++) {
            sum += cArr[i] = Integer.parseInt(st.nextToken());
        }

        int[][] dp = new int[1 + N][1 + sum];

        for (int i = 1; i <= N; i++) {
            int m = mArr[i];
            int c = cArr[i];

            for (int j = 0; j <= sum; j++) {
                if (j < c) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j - c] + m, dp[i - 1][j]);
                }
            }
        }

        for (int j = 0; j <= sum; j++) {
            if (dp[N][j] >= M) {
                System.out.println(j);
                return;
            }
        }
    }
}
```

### 2. Bottom-Up 1차원 dp [Java]

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int N = Integer.parseInt(st.nextToken());
        int M = Integer.parseInt(st.nextToken());

        int[] mArr = new int[N];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            mArr[i] = Integer.parseInt(st.nextToken());
        }

        int[] cArr = new int[N];
        int sum = 0;
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            sum += cArr[i] = Integer.parseInt(st.nextToken());
        }

        int[] dp = new int[1 + sum];

        for (int i = 0; i < N; i++) {
            int m = mArr[i];
            int c = cArr[i];

            for (int j = sum; j >= c; j--) {
                dp[j] = Math.max(dp[j - c] + m, dp[j]);
            }
        }

        for (int j = 0; j <= sum; j++) {
            if (dp[j] >= M) {
                System.out.println(j);
                return;
            }
        }
    }
}
```

---

## 풀이 정보

### 1. Bottom-Up 2차원 dp [Java]

- 4 min

![](/assets/posts/2025-11/백준%207579%20앱/photo3.png)

### 2. Bottom-Up 1차원 dp [Java]

- 42 min

![](/assets/posts/2025-11/백준%207579%20앱/photo4.png)

---
