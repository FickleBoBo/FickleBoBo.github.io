---
title: "[BaekJoon] 3197번 - 백조의 호수 [Java][C++]"
slug: baekjoon-3197
date: 2026-02-01
categories: [PS, BaekJoon]
tags: [Graphs, Shortest Path, BFS, Binary Search, Parametric Search]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/3197)

---

## 1. 문제 풀이

<br>

물과 닿은 얼음은 매일 녹을 때 며칠 후 두 백조가 만날 수 있는지 구하는 문제로 단순히 얼음을 녹이고 백조가 만날 수 있는지 찾는 방식을 반복하는 것으로는 시간 내에 해결할 수 없다. 호수의 각 얼음에 대해 해당 얼음이 며칠 뒤에 녹는지를 전부 구한 후 매개 변수 이분 탐색을 통해 두 백조가 만날 수 있는 날을 탐색하는 방식으로 해결했다.

먼저 각 얼음이 녹는 날을 모두 구해야 하는데 이를 위해 호수를 한번 순회하며 물과 맞닿은 얼음의 좌표를 큐에 담았다. 이후 해당 큐에 대해 주변 얼음을 탐색하며 거리를 저장하면 해당 2차원 배열이 해당 좌표의 얼음이 녹는 날을 저장한 배열이 된다.

이후 해당 배열의 최댓값을 구하면 두 백조는 $0$ 일에서 최댓값에 해당하는 일 사이에서는 반드시 만나게 되므로 이를 매개변수 이분 탐색을 통해 특정일 이내에 녹는 얼음은 지나갈 수 있다고 가정하고 BFS를 돌려서 두 백조가 만날 수 있는 최솟값을 구했다.

---

## 2. 코드

<br>

### 1. 풀이 [Java]

```java
import java.io.*;
import java.util.*;

public class Main {

    static int[] dr = {-1, 0, 1, 0};
    static int[] dc = {0, 1, 0, -1};
    static int n, m;
    static char[][] grid;
    static List<int[]> pos = new ArrayList<>();

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        grid = new char[n][m];
        for (int i = 0; i < n; i++) {
            grid[i] = br.readLine().toCharArray();
            for (int j = 0; j < m; j++) {
                if (grid[i][j] == 'L') pos.add(new int[]{i, j});
            }
        }

        boolean[][] visited = new boolean[n][m];
        int[][] mark = new int[n][m];
        Queue<int[]> ice = new ArrayDeque<>();

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (grid[i][j] != 'X' && !visited[i][j]) {
                    Queue<int[]> result = bfs(i, j, visited);
                    ice.addAll(result);
                }
            }
        }
        bfs(ice, visited, mark);

        int max = 0;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                max = Math.max(max, mark[i][j]);
            }
        }

        System.out.println(lowerBound(max, mark));
    }

    static Queue<int[]> bfs(int sr, int sc, boolean[][] visited) {
        Queue<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{sr, sc});

        visited[sr][sc] = true;

        Queue<int[]> ice = new ArrayDeque<>();

        while (!q.isEmpty()) {
            int[] node = q.poll();

            for (int d = 0; d < 4; d++) {
                int nr = node[0] + dr[d];
                int nc = node[1] + dc[d];

                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                if (visited[nr][nc]) continue;
                if (grid[nr][nc] == 'X') {
                    ice.offer(new int[]{nr, nc});
                    visited[nr][nc] = true;
                    continue;
                }

                q.offer(new int[]{nr, nc});
                visited[nr][nc] = true;
            }
        }

        return ice;
    }

    static void bfs(Queue<int[]> q, boolean[][] visited, int[][] mark) {
        int dist = 1;

        while (!q.isEmpty()) {
            int size = q.size();

            while (size-- > 0) {
                int[] node = q.poll();
                mark[node[0]][node[1]] = dist;

                for (int d = 0; d < 4; d++) {
                    int nr = node[0] + dr[d];
                    int nc = node[1] + dc[d];

                    if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                    if (grid[nr][nc] != 'X' || visited[nr][nc]) continue;

                    q.offer(new int[]{nr, nc});
                    visited[nr][nc] = true;
                }
            }

            dist++;
        }
    }

    static int lowerBound(int max, int[][] mark) {
        int left = 0;
        int right = max;

        while (left < right) {
            int mid = (left + right) / 2;

            if (!bfs(mid, mark)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return right;
    }

    static boolean bfs(int max, int[][] mark) {
        int sr = pos.get(0)[0];
        int sc = pos.get(0)[1];
        int er = pos.get(1)[0];
        int ec = pos.get(1)[1];

        Queue<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{sr, sc});

        boolean[][] visited = new boolean[n][m];
        visited[sr][sc] = true;

        while (!q.isEmpty()) {
            int[] node = q.poll();
            if (node[0] == er && node[1] == ec) return true;

            for (int d = 0; d < 4; d++) {
                int nr = node[0] + dr[d];
                int nc = node[1] + dc[d];

                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                if (mark[nr][nc] > max || visited[nr][nc]) continue;

                q.offer(new int[]{nr, nc});
                visited[nr][nc] = true;
            }
        }

        return false;
    }
}
```

<br>

### 2. 풀이 [C++]

```c++
#include <bits/stdc++.h>
using namespace std;

int dr[4] = {-1, 0, 1, 0};
int dc[4] = {0, 1, 0, -1};
int n, m;
char grid[1500][1500];
bool visited[1500][1500];
int mark[1500][1500];
vector<pair<int, int>> pos;
queue<pair<int, int>> ice;

queue<pair<int, int>> bfs(int sr, int sc) {
    queue<pair<int, int>> q;
    q.push({sr, sc});

    visited[sr][sc] = true;

    queue<pair<int, int>> q2;

    while (!q.empty()) {
        auto [r, c] = q.front();
        q.pop();

        for (int d = 0; d < 4; d++) {
            int nr = r + dr[d];
            int nc = c + dc[d];

            if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
            if (visited[nr][nc]) continue;
            if (grid[nr][nc] == 'X') {
                q2.push({nr, nc});
                visited[nr][nc] = true;
                continue;
            }

            q.push({nr, nc});
            visited[nr][nc] = true;
        }
    }

    return q2;
}

void bfs() {
    int dist = 1;

    while (!ice.empty()) {
        int sz = ice.size();

        while (sz--) {
            auto [r, c] = ice.front();
            ice.pop();
            mark[r][c] = dist;

            for (int d = 0; d < 4; d++) {
                int nr = r + dr[d];
                int nc = c + dc[d];

                if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
                if (grid[nr][nc] != 'X' || visited[nr][nc]) continue;

                ice.push({nr, nc});
                visited[nr][nc] = true;
            }
        }

        dist++;
    }
}

bool bfs(int mx) {
    auto [sr, sc] = pos[0];
    auto [er, ec] = pos[1];

    queue<pair<int, int>> q;
    q.push({sr, sc});

    memset(visited, 0, sizeof(visited));
    visited[sr][sc] = true;

    while (!q.empty()) {
        auto [r, c] = q.front();
        q.pop();

        if (r == er && c == ec) return true;

        for (int d = 0; d < 4; d++) {
            int nr = r + dr[d];
            int nc = c + dc[d];

            if (nr < 0 || nr >= n || nc < 0 || nc >= m) continue;
            if (mark[nr][nc] > mx || visited[nr][nc]) continue;

            q.push({nr, nc});
            visited[nr][nc] = true;
        }
    }

    return false;
}

int lower_bound_param(int mx) {
    int left = 0;
    int right = mx;

    while (left < right) {
        int mid = (left + right) / 2;

        if (!bfs(mid)) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return right;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m;

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> grid[i][j];
            if (grid[i][j] == 'L') pos.push_back({i, j});
        }
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (grid[i][j] != 'X' && !visited[i][j]) {
                queue<pair<int, int>> res = bfs(i, j);
                while (!res.empty()) {
                    ice.push(res.front());
                    res.pop();
                }
            }
        }
    }
    bfs();

    int mx = 0;
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            mx = max(mx, mark[i][j]);
        }
    }

    cout << lower_bound_param(mx);
}
```

---
