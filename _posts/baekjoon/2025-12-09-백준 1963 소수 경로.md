---
title: "[BaekJoon] 1963번 - 소수 경로 [Java][C++]"
slug: baekjoon-1963
date: 2025-12-09
categories: [PS, BaekJoon]
tags:
  [
    Number Theory,
    Primality Test,
    Sieve of Eratosthenes,
    Graphs,
    Shortest Path,
    BFS,
  ]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/1963)

---

## 1. 문제 풀이

<br>

주어진 4자리 소수에 대해 특정 자리를 바꾸는 과정을 반복해서 다음 소수를 만들어야 하는 문제다. 이때 바꾸는 과정도 전부 소수여야 한다. [에라토스테네스의 체](/posts/sieve-of-eratosthenes) 를 활용해 4자리 소수를 전부 구한 후 BFS를 통해 각 자리를 바꿨을 때, 소수이면 계속 탐색하고 아니면 탐색하지 않는 방향으로 해결할 수 있다.

---

## 2. 코드

<br>

### 1. 풀이 [Java]

```java
import java.io.*;
import java.util.*;

public class Main {

    static final int MAX = 10_000;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        StringTokenizer st;

        boolean[] isPrime = sieve();

        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            st = new StringTokenizer(br.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());

            int dist = bfs(a, b, isPrime);
            if (dist == -1) {
                sb.append("Impossible\n");
            } else {
                sb.append(dist).append("\n");
            }
        }

        System.out.println(sb);
    }

    static boolean[] sieve() {
        boolean[] isPrime = new boolean[1 + MAX];
        Arrays.fill(isPrime, true);
        isPrime[0] = isPrime[1] = false;

        for (int i = 2; i * i <= MAX; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= MAX; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        return isPrime;
    }

    static int bfs(int a, int b, boolean[] isPrime) {
        Queue<Integer> q = new ArrayDeque<>();
        q.offer(a);

        boolean[] visited = new boolean[MAX];
        visited[a] = true;

        int dist = 0;

        while (!q.isEmpty()) {
            int size = q.size();

            while (size-- > 0) {
                int node = q.poll();
                if (node == b) return dist;

                for (int i = 0; i < 10; i++) {
                    int num1 = node / 10 * 10 + i;  // 일의 자리 변경
                    int num2 = node / 100 * 100 + i * 10 + node % 10;  // 십의 자리 변경
                    int num3 = node / 1000 * 1000 + i * 100 + node % 100;  // 백의 자리 변경
                    int num4 = i * 1000 + node % 1000;  // 천의 자리 변경

                    if (isPrime[num1] && !visited[num1]) {
                        q.offer(num1);
                        visited[num1] = true;
                    }

                    if (isPrime[num2] && !visited[num2]) {
                        q.offer(num2);
                        visited[num2] = true;
                    }

                    if (isPrime[num3] && !visited[num3]) {
                        q.offer(num3);
                        visited[num3] = true;
                    }

                    if (num4 >= 1_000 && isPrime[num4] && !visited[num4]) {
                        q.offer(num4);
                        visited[num4] = true;
                    }
                }
            }

            dist++;
        }

        return -1;
    }
}
```

<br>

### 2. 풀이 [C++]

```c++
#include <bits/stdc++.h>
using namespace std;

constexpr int MAX = 10000;
bool isPrime[MAX];

void sieve() {
    fill(isPrime, isPrime + MAX + 1, true);
    isPrime[0] = isPrime[1] = false;

    for (int i = 2; i * i <= MAX; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= MAX; j += i) {
                isPrime[j] = false;
            }
        }
    }
}

int bfs(int a, int b) {
    queue<int> q;
    q.push(a);

    vector<bool> visited(MAX);
    visited[a] = true;

    int dist = 0;

    while (!q.empty()) {
        int sz = q.size();

        while (sz--) {
            int node = q.front();
            q.pop();

            if (node == b) return dist;

            for (int i = 0; i < 10; i++) {
                int n1 = node / 10 * 10 + i;                         // 일의 자리 변경
                int n2 = node / 100 * 100 + i * 10 + node % 10;      // 십의 자리 변경
                int n3 = node / 1000 * 1000 + i * 100 + node % 100;  // 백의 자리 변경
                int n4 = i * 1000 + node % 1000;                     // 천의 자리 변경

                if (isPrime[n1] && !visited[n1]) {
                    q.push(n1);
                    visited[n1] = true;
                }

                if (isPrime[n2] && !visited[n2]) {
                    q.push(n2);
                    visited[n2] = true;
                }

                if (isPrime[n3] && !visited[n3]) {
                    q.push(n3);
                    visited[n3] = true;
                }

                if (n4 >= 1000 && isPrime[n4] && !visited[n4]) {
                    q.push(n4);
                    visited[n4] = true;
                }
            }
        }

        dist++;
    }

    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    sieve();

    int t;
    cin >> t;

    while (t--) {
        int a, b;
        cin >> a >> b;

        int dist = bfs(a, b);
        if (dist == -1) {
            cout << "Impossible\n";
        } else {
            cout << dist << '\n';
        }
    }
}
```

---
