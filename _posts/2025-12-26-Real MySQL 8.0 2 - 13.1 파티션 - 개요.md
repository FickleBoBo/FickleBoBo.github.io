---
title: "[Real MySQL 8.0 2] 13.1 파티션 - 개요"
slug: real-mysql-8-0-2-13-1
date: 2025-12-26
categories: [Database, MySQL]
tags: [Real MySQL 8.0 2]
toc: true
math: true
image: /assets/posts/real-mysql-8-0-2/thumbnail.jpg
---

> 파티션 기능은 테이블을 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리해서 관리할 수 있게 해준다. 파티션 기능은 주로 대용량 테이블을 물리적으로 여러 개의 소규모 테이블로 분산하는 목적으로 사용한다. 하지만 파티션 기능은 대용량 테이블에 사용하면 무조건 성능이 빨라지는 만병 통치약은 아니다. 어떤 쿼리를 사용하느냐에 따라 오히려 성능이 더 나빠지는 경우도 자주 발생할 수 있다. MySQL 서버는 다양한 파티션 방법을 제공하지만 여기서는 자주 사용하는 파티션 방법과 주의해야 할 사항 위주로 살펴보겠다.

---

## 1. 파티션을 사용하는 이유

<br>

### 1. 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

데이터베이스에서 인덱스는 일반적으로 `SELECT`를 위한 것으로 보이지만 변경 대상 레코드를 검색해야 한다는 점에서 `UPDATE`나 `DELETE`와 같은 쿼리도 인덱스가 필요할 수 있다. 하지만 인덱스가 커지면 `SELECT`는 물론이고, `INSERT`나 `UPDATE`, `DELETE`와 같은 쿼리도 느려질 수 있다.

이때 한 테이블의 인덱스의 크기가 물리적으로 MySQL이 사용 가능한 메모리 공간보다 크다면 쿼리 처리가 상당히 느려질 것인데 파티션을 통해 하나의 큰 테이블과 인덱스를 조각화한다면 물리적 메모리를 효율적으로 사용할 수 있다.

<br>

### 2. 데이터의 물리적인 저장소를 분리

데이터 파일이나 인덱스 파일이 파일 시스템에서 차지하는 공간이 크다면 그만큼 백업이나 관리 작업이 어려워진다. 특히 테이블의 데이터나 인덱스를 파일 단위로 관리하는 MySQL에서 더 치명적인 문제가 될 수도 있다. 이런 문제를 파티션을 통해 파일의 크기를 조절하거나 파티션별 파일들이 저장될 위치나 디스크를 구분해서 지정해 해결하는 것도 가능하다.(하지만 MySQL에서는 테이블의 파티션 단위로 인덱스를 생성하거나 파티션별로 다른 인덱스를 가지는 형태는 지원하지 않는다.)

<br>

### 3. 이력 데이터의 효율적인 관리

로그 데이터는 단기간에 대량으로 누적되지만 일정 기간이 지나면 쓸모가 없어진다는 특징이 있다. 로그 데이터는 시간이 지나면 별도로 아카이빙하거나 백업한 후 삭제해버리는 것이 일반적이며 다른 데이터에 비해 라이프 사이클이 상당히 짧은데 이런 로그 테이블에서 불필요해진 데이터를 백업하거나 삭제하는 고부하 작업을 파티션으로 관리하면 단순한 파티션 추가, 삭제로 간단하고 빠르게 해결할 수 있다.

---

## 2. MySQL 파티션의 내부 처리

<br>

### 1. 파티션 테이블의 레코드 INSERT

`INSERT` 쿼리가 실행되면 MySQL 서버는 `INSERT`되는 컬럼의 값 중에서 파티션 키 컬럼의 값을 이용해 파티션 표현식을 평가하고, 그 결과를 이용해 레코드가 저장될 적절한 파티션을 결정한다.

<br>

### 2. 파티션 테이블의 UPDATE

`UPDATE` 쿼리를 실행하려면 변경 대상 레코드가 어느 파티션에 저장돼 있는지 찾아야 한다. 이때 `UPDATE` 쿼리의 `WHERE` 절 조건에 파티션 키 컬럼이 조건으로 존재한다면 그 값을 이용해 레코드가 저장된 파티션에서 빠르게 대상 레코드를 검색할 수 있다. 하지만 `WHERE` 절 조건에 파티션 키 컬럼의 조건이 명시되지 않았다면 MySQL 서버는 변경 대상 레코드를 찾기 위해 테이블의 모든 파티션을 검색해야 한다.

실제 레코드를 변경하는 작업은 파티션 키 이외의 컬럼만 변경될 때는 파티션이 적용되지 않은 일반 테이블과 마찬가지로 컬럼 값만 변경하고, 파티션 키 컬럼이 변경될 때는 기존의 레코드가 저장된 파티션에서 해당 레코드를 삭제하고, 레코드를 이동시킬 새로운 파티션을 결정해서 레코드를 새로 저장한다.

<br>

### 3. 파티션 데이블의 검색

`WHERE` 절 조건으로 검색해야 할 파티션을 선택할 수 있는지 여부와 `WHERE` 절 조건이 인덱스를 효율적으로 이용할 수 있는지(인덱스 레인지 스캔)에 영향을 받는다.

<br>

### 4. 파티션 테이블의 인덱스 스캔과 정렬

파티션 테이블에서 인덱스는 로컬 인덱스로 해당 파티션에만 적용되며 테이블 단위의 인덱스는 지원하지 않는다. 인덱스 레인지 스캔이 여러 파티션을 읽어야 할 경우 실제 MySQL 서버는 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위 큐에 임시로 저장한다. 그리고 우선순위 큐에서 다시 필요한 순서대로 데이터를 가져온다.

<br>

### 5. 파티션 프루닝

최적화 단계에서 필요한 파티션만 골라내고 불필요한 것들은 실행 계획에서 배제하는 것을 파티션 프루닝이라고 한다.

---

## Ref

<br>

- Real MySQL 8.0 2 - p.262 ~ p.271

---
