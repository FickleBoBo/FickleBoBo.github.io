---
title: "[백준] 27436번 - 벌집 2 [Java]"
date: 2025-11-06
categories: [알고리즘, 백준]
tags: [수학, 이분 탐색, 매개 변수 탐색]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/27436)

![](/assets/posts/2025-11/백준%2027436%20벌집%202/photo1.png)
![](/assets/posts/2025-11/백준%2027436%20벌집%202/photo2.png)

---

## 문제 풀이

[[백준] 2292번 - 벌집 [Java]]({% post_url 2025-11/2025-11-06-백준 2292 벌집 %}) 해당 문제에서 시간 제한이 더 빡빡해지고 `N`의 범위가 훨씬 커졌다. 기존처럼 반복문으로 찾는 방식으로는 해결할 수 없는데 이분 탐색과 매개 변수 탐색을 활용하면 해결할 수 있다.

매개 변수 탐색은 주어진 `N`의 범위에서 가능한 정답의 하한과 상한을 정하고 조건을 만족하는지 비교하며 찾으면 된다. 방은 최소 1개는 지나야 하기에 하한은 `1`이며, `N`이 최대 `9 * 10^18` 이므로 이전 문제에서 얻은 공식인 `9 * 10^18 = 3 * n * (n - 1) + 1`을 활용하면 대략 `2,000,000,000` 정도로 어림할 수 있다. 정답이 `1 ~ 2,000,000,000` 사이에 반드시 존재하므로 이분 탐색을 통해 `n`의 값을 찾아나가면 된다. 이때 `N`을 포함하는 거리를 구해야하므로 Lower bound로 탐색했다.

---

## 코드

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        long N = Long.parseLong(br.readLine());

        System.out.println(lowerBound(N));
    }

    private static long lowerBound(long key) {
        long left = 1;
        long right = 2_000_000_000;

        while (left < right) {
            long mid = (left + right) / 2;

            // n개의 방을 지나면 최대 3 * n * (n - 1) + 1번 방까지 갈 수 있음
            if ((3 * mid * (mid - 1) + 1) < key) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return right;
    }
}
```

---

## 풀이 정보

- 47 min

![](/assets/posts/2025-11/백준%2027436%20벌집%202/photo3.png)

---

## 리뷰

수열에 이분 탐색, 매개 변수 탐색까지 필요해서 티어에 비하면 어려운 문제 같다. 추가로 상한 범위를 잘못 설정하면 `long` 타입도 오버플로우가 나서 제법 까다로웠다.

---
