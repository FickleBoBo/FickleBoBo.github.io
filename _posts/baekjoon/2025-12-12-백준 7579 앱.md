---
title: "[BaekJoon] 7579번 - 앱 [Java][C++]"
slug: baekjoon-7579
date: 2025-12-12
categories: [PS, BaekJoon]
tags: [Dynamic Programming, Knapsack]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/7579)

---

## 1. 문제 풀이

<br>

활성화된 앱들이 주어져 있고 각 앱은 비활성화 했을 때, 비용 $c$ 와 확보할 수 있는 메모리 $m$ 을 가지고 있다. 이때 $M$ 이상의 메모리를 확보할 때 최소 비용을 알아내야 하는 문제다. 이는 비용을 무게, 확보할 수 있는 메모리를 가치로 간주하는 [0/1 배낭 문제](/posts/0-1-knapsack-problem) 로 해결할 수 있다. 각 앱을 비활성화하느냐 마느냐를 0/1 배낭 문제로 쭉 계산한 후 비용이 $0$ 일 때 확보할 수 있는 메모리부터 쭉 탐색해서 확보할 수 있는 메모리가 $M$ 이상이면 종료하면 된다.

비활성화 했을 때 비용이 $0$ 일 수 있음에 주의해야 한다.

---

## 2. 코드

<br>

### 1. Bottom-Up 2차원 dp [Java]

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        int[] marr = new int[1 + n];
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            marr[i] = Integer.parseInt(st.nextToken());
        }

        int[] carr = new int[1 + n];
        int sum = 0;
        st = new StringTokenizer(br.readLine());
        for (int i = 1; i <= n; i++) {
            sum += carr[i] = Integer.parseInt(st.nextToken());
        }

        int[][] dp = new int[1 + n][1 + sum];
        for (int i = 1; i <= n; i++) {
            int m = marr[i];
            int c = carr[i];

            for (int j = 0; j <= sum; j++) {
                if (j < c) {
                    dp[i][j] = dp[i - 1][j];
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j - c] + m, dp[i - 1][j]);
                }
            }
        }

        for (int j = 0; j <= sum; j++) {
            if (dp[n][j] >= k) {
                System.out.println(j);
                return;
            }
        }
    }
}
```

<br>

### 2. Bottom-Up 1차원 dp [Java]

```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int k = Integer.parseInt(st.nextToken());

        int[] marr = new int[n];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            marr[i] = Integer.parseInt(st.nextToken());
        }

        int[] carr = new int[n];
        int sum = 0;
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < n; i++) {
            sum += carr[i] = Integer.parseInt(st.nextToken());
        }

        int[] dp = new int[1 + sum];
        for (int i = 0; i < n; i++) {
            int m = marr[i];
            int c = carr[i];

            for (int j = sum; j >= c; j--) {
                dp[j] = Math.max(dp[j - c] + m, dp[j]);
            }
        }

        for (int j = 0; j <= sum; j++) {
            if (dp[j] >= k) {
                System.out.println(j);
                return;
            }
        }
    }
}
```

<br>

### 3. Bottom-Up 2차원 dp [C++]

```c++
#include <bits/stdc++.h>
using namespace std;

int dp[101][10001];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<int> ma(n);
    for (int& x : ma) cin >> x;

    vector<int> ca(n);
    for (int& x : ca) cin >> x;

    int sum = 0;
    for (int x : ca) sum += x;

    for (int i = 1; i <= n; i++) {
        int mi = ma[i - 1];
        int ci = ca[i - 1];

        for (int j = 0; j <= sum; j++) {
            if (j < ci) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = max(dp[i - 1][j - ci] + mi, dp[i - 1][j]);
            }
        }
    }

    for (int j = 0; j <= sum; j++) {
        if (dp[n][j] >= m) {
            cout << j;
            return 0;
        }
    }
}
```

<br>

### 4. Bottom-Up 1차원 dp [C++]

```c++
#include <bits/stdc++.h>
using namespace std;

int dp[10001];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;

    vector<int> ma(n);
    for (int& x : ma) cin >> x;

    vector<int> ca(n);
    for (int& x : ca) cin >> x;

    int sum = 0;
    for (int x : ca) sum += x;

    for (int i = 0; i < n; i++) {
        int mi = ma[i];
        int ci = ca[i];

        for (int j = sum; j >= ci; j--) {
            dp[j] = max(dp[j - ci] + mi, dp[j]);
        }
    }

    for (int j = 0; j <= sum; j++) {
        if (dp[j] >= m) {
            cout << j;
            return 0;
        }
    }
}
```

---
