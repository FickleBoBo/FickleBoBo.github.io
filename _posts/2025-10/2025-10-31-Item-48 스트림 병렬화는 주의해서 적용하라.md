---
title: "[Item-48] 스트림 병렬화는 주의해서 적용하라"
date: 2025-10-31
categories: [Java, Effective Java 3/E]
tags: [Effective Java 3/E]
toc: true
math: true
image: /assets/posts/2025-10/Item-48%20스트림%20병렬화는%20주의해서%20적용하라/thumbnail.jpg
---

## Intro

Java는 주류 언어 중, 동시성 프로그래밍 측면에서 항상 앞서나갔다. 처음부터 멀티스레딩을 염두하고 설계된 Java는 릴리스 됐을 때 부터 스레드, 동기화, `wait()`, `notify()`를 지웠했다. Java 5부터는 동시성 컬렉션과 `Excutor` 프레임워크를 지원했다. Java 7부터는 고성능 병렬 분해 프레임워크인 `fork-join` 패키지를 추가했다. 그리고 Java 8부터는 `parellel()` 메서드만 한 번 호출하면 파이프라인을 병렬로 실행할 수 있는 스트림을 지원했다. 하지만 병렬 스트림의 경우 계산을 올바르게 수행하고 성능도 빨라질 거라는 확신 없이 사용하면 대재앙을 초래할 수 있다. 병렬 스트림의 적용은 운영 환경과 유사한 조건에서 성능지표를 유심히 관찰하며 계산도 정확하고 성능도 좋아졌음이 확실해졌을 때만 운영 코드에 반영해라.

---

## 병렬 스트림

병렬은 동시에(진짜 동시) 수행한다는 말로 1초가 걸리는 작업을 3번 수행해야할 때 싱글 코어를 활용하면 3초가 걸릴 것을 멀티 코어를 통해 병렬로 수행하여 1초만에 완료할 수 있다. 스트림도 병렬 스트림을 활용하면 이런 병렬의 이점을 얻을 수 있으며 겨우 `parallel()`만 붙이면 된다.

병렬 스트림은 공용 Fork-Join 풀을 사용해서 병렬 연산을 수행하며 내부적으로 병렬 처리 가능한 스레드 숫자와 작업의 크기 등을 확인하면서, `Spliterator`를 통해 데이터를 자동으로 분할한다.

공용 Fork-Join 풀은 Java 8부터 도입된 것으로 Fork/Join 작업을 위한 기본 스레드 풀이다. 시스템 전체에서 공유하는 단일 인스턴스로 병렬 스트림도 내부적으로 이 공용 Fork-join 풀을 사용한다. Fork/Join은 분할 정복, 작업 훔치기를 통해 큰 작업을 작은 작업으로 나누어 스레드가 처리하고 이를 합치며 작업 훔치기를 통해 부하 균형을 조절한다.

---

## 병렬 스트림의 부작용

메르센 수는 2<sup>p</sup> - 1 형태의 수인데 여기서 `p`가 소수이면 해당 메르센 수도 소수일 수 있는데 이때의 수를 메르센 소수라 한다.

- p = 2 -> 2<sup>2</sup> - 1 = 3 -> 3은 소수이므로 메르센 소수
- p = 3 -> 2<sup>3</sup> - 1 = 7 -> 7은 소수이므로 메르센 소수
- p = 5 -> 2<sup>5</sup> - 1 = 31 -> 31은 소수이므로 메르센 소수
- p = 7 -> 2<sup>7</sup> - 1 = 127 -> 127은 소수이므로 메르센 소수
- p = 11 -> 2<sup>11</sup> - 1 = 2047 -> 2047은 소수가 아니므로 메르센 소수가 아님(23 \* 89 = 2047)

아래는 처음 20개의 메르센 소수를 출력하는 프로그램으로 `primes()` 메서드는 무한 스트림을 반환하는 메서드로 `TWO`와 `BigInteger::nextProbablePrime`를 통해 소수를 얻을 수 있다.

```java
import java.math.BigInteger;
import java.util.stream.Stream;

import static java.math.BigInteger.*;

public class MersennePrimeMain {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        primes().map(p -> TWO.pow(p.intValueExact()).subtract(ONE)) // 2^p-1로 매핑
                .filter(mersenne -> mersenne.isProbablePrime(50))  // 소수 여부를 판별
                .limit(20)  // 20개만
                .forEach(System.out::println);  // 출력

        long end = System.currentTimeMillis();
        System.out.println("Total time: " + (end - start) + "ms");  // Total time: 3447ms
    }

    private static Stream<BigInteger> primes() {
        return Stream.iterate(TWO, BigInteger::nextProbablePrime);
    }
}
```

위 프로그램의 성능을 높이고자 병렬 스트림을 적용할 경우 아무것도 출력하지 못하는 상태가 지속된다. `parallel()`을 어디에 붙여도 다 안된다.

해당 문제의 원인은 스트림 라이브러리가 이 파이프라인을 병렬화할 방법을 찾아내지 못했기 때문으로 `Stream.iterate`나 `limit`을 쓰면 병렬화로는 성능 개선을 기대할 수 없다고 한다.

또한 병렬 스트림이 사용하는 공용 Fork-Join 풀은 시스템 전체가 공유하는 자원으로 잘못된 병렬 스트림을 사용하거나 병렬 스트림을 남용하면 전체 시스템 성능에 문제가 생길 수 있다.

---

## 병렬 스트림의 효능

아래는 2부터 10<sup>7</sup> 사이의 소수의 개수를 구하는 예제로 병렬 스트림을 통해 훨씬 빠르게 계산하는 것을 볼 수 있다.

```java
public class PiMain {

    private static long start;
    private static long end;
    private static long num = 10_000_000L;

    public static void main(String[] args) {
        start = System.currentTimeMillis();
        System.out.println(pi1(num));  // 664579
        end = System.currentTimeMillis();
        System.out.println("Total time: " + (end - start) + "ms");  // Total time: 13144ms

        start = System.currentTimeMillis();
        System.out.println(pi2(num));  // 664579
        end = System.currentTimeMillis();
        System.out.println("Total time: " + (end - start) + "ms");  // Total time: 2455ms
    }

    private static long pi1(long n) {
        return LongStream.rangeClosed(2, n)
                .mapToObj(BigInteger::valueOf)
                .filter(i -> i.isProbablePrime(50))
                .count();
    }

    private static long pi2(long n) {
        return LongStream.rangeClosed(2, n)
                .parallel()
                .mapToObj(BigInteger::valueOf)
                .filter(i -> i.isProbablePrime(50))
                .count();
    }
}
```

병렬 스트림에서 공용 Fork-Join 풀의 스레드를 활용하는 것을 같이 볼 수 있게 `filter()`를 추가하면 아래와 같이 된다.

```java
public class PiMain2 {

    private static long num = 15L;

    public static void main(String[] args) {
        // JVM이 인식한 코어 수
        System.out.println("processorCount = " + Runtime.getRuntime().availableProcessors());

        // 공용 Fork-Join 풀의 워커 스레드의 수(보통 코어 수 - 1)
        System.out.println("commonPool = " + ForkJoinPool.commonPool().getParallelism());

        System.out.println("cnt = " + pi2(num));
    }

    private static long pi2(long n) {
        return LongStream.rangeClosed(2, n)
                .parallel()
                .mapToObj(BigInteger::valueOf)
                .filter(i -> i.isProbablePrime(50))
                .filter(i -> {
                    System.out.println(Thread.currentThread().getName() + " : " + i);
                    return true;
                })
                .count();
    }
}
```

아래와 같이 작업에 참여한 워커 스레드가 각각 출력되는 것을 볼 수 있었다.

```
출력 결과

processorCount = 8
commonPool = 7
main : 11
ForkJoinPool.commonPool-worker-7 : 2
ForkJoinPool.commonPool-worker-5 : 13
ForkJoinPool.commonPool-worker-1 : 5
ForkJoinPool.commonPool-worker-3 : 3
ForkJoinPool.commonPool-worker-6 : 7
cnt = 6
```

---
