---
title: "[Item-26] 로 타입은 사용하지 말라"
date: 2025-10-20
categories: [Book, Effective Java 3/E]
tags: [Effective Java 3/E]
toc: true
math: true
image: /assets/posts/2025-10/Item-26%20로%20타입은%20사용하지%20말라/thumbnail.jpg
---

## 로 타입(Raw Type)과 제네릭 타입(Generic Type)

제네릭 클래스와 제네릭 인터페이스를 통틀어 제네릭 타입이라고 하며 제네릭 클래스, 제네릭 인터페이스는 클래스와 인터페이스 선언에 타입 매개변수(Type Paramter)를 사용한 것이다.

![](/assets/posts/2025-10/Item-26%20로%20타입은%20사용하지%20말라/assets/photo1.png)
![](/assets/posts/2025-10/Item-26%20로%20타입은%20사용하지%20말라/assets/photo2.png)

제네릭은 코드 재사용과 타입 안전성 두 가지를 모두 챙길 수 있는 장점이 있는데 대표적으로 컬렉션 프레임워크가 있다. 제네릭 덕분에 컬렉션 프레임워크는 내부적으로 `Object` 타입의 컨테이너를 활용하여 타입별로 별도의 컬렉션을 만들지 않지만 타입 안전성을 챙길 수 있다. 또한 타입 매개변수라는 말처럼 제네릭은 사용할 타입을 미리 결정하지 않고 전달 받는다.

로 타입은 제네릭 타입에서 타입 매개변수를 전혀 사용하지 않은 경우로 JDK 1.5부터 새로 도입된 제네릭에 대해 이전 코드와의 호환성을 위해 존재한다. 로 타입은 사용하지 말자.

---

## 제네릭 용어 정리

`List<E>` -> `List<Integer>`

제네릭 타입(Generic Type)

- `List<E>`

타입 매개변수(Type Parameter)

- `E`

타입 인자(Type Argument)

- `Integer`

로 타입(Raw Type)

- `List`

---

## 로 타입의 문제점

아래는 로 타입을 사용한 예시로 숫자를 저장하는 리스트를 만들었지만 해당 리스트에는 어떤 타입이든 다 저장할 수 있다. 이는 타입 안전성이 떨어지고 데이터를 저장하는 로직과 활용하는 로직이 구분되어 있을 경우 예외 발생 시 원인을 찾기 어렵다. 제네릭 타입을 적용한다면 컴파일 타임에 타입 안전성을 체크할 수 있고 형변환의 번거로움도 줄일 수 있다.

```java
public class RawTypeTest1Main {

    public static void main(String[] args) {
        List numberList = new ArrayList();

        numberList.add(1);
        numberList.add('1');
        numberList.add("1");

        // iter로 순회하면 Object 타입으로 꺼내짐
        for (Object o : numberList) {
            System.out.println(o);
        }

        // 출력 결과
        // 1
        // 1
        // 1
    }
}
```

---

## `로 타입`과 `<Object>`

리스트에 주어진 원소를 적재하는 메서드를 상상해보자. 클라이언트는 제네릭 타입 리스트를 만들고 해당 메서드에 적재할 데이터를 넘긴다. 이때 메서드에서 리스트를 로 타입으로 받을 경우 타입 안전성이 깨질 수 있다.

```java
    public static void main(String[] args) {
        List<String> stringList = new ArrayList<>();

        unsafeAdd(stringList, 1);
        String s = stringList.get(0);
        // ClassCastException 발생 -> 컴파일 타임에 잡지 못한다
    }

    private static void unsafeAdd(List list, Object o) {
        list.add(o);
    }
```

코드 재사용을 위해 하나의 메서드로 해당 기능을 제공하려고 `<Object>`를 활용할 경우 아예 컴파일이 되지 않는다. 아래처럼 `List<String>`은 `List<Object>`의 하위 타입이 아니어서 파라미터 타입이 맞지 않는 것인데 `String`은 `Object`의 하위 타입이지만 `List<String>`은 `List<Object>`의 하위 타입이 아니라는 점에 주의해야 한다.(제네릭은 기본적으로 불공변)

```java
    public static void main(String[] args) {
        List<String> stringList = new ArrayList<>();

        errorAdd(stringList, 1);
        // List<String>은 List<Object>의 하위 타입이 아니라서 컴파일 에러 발생
    }

    private static void errorAdd(List<Object> list, Object o) {
        list.add(o);
    }
```

아래처럼 제네릭 메서드를 활용하면 하나의 메서드로 다양한 제네릭 타입 리스트들에 대한 적재 로직을 제공할 수 있다.

```java
    public static void main(String[] args) {
        List<String> stringList = new ArrayList<>();

        safeAdd(stringList, 1);
        // 제네릭 메서드를 활용해 타입 안전성을 챙기면서 타입 별로 메서드 오버로딩을 하지 않아도 된다
    }

    private static <E> void safeAdd(List<E> list, E e) {
        list.add(e);
    }
```

---
