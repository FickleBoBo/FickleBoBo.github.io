---
title: "[Item-45] 스트림은 주의해서 사용하라"
date: 2025-10-31
categories: [Java, Effective Java 3/E]
tags: [Effective Java 3/E]
toc: true
math: true
image: /assets/posts/2025-10/Item-45%20스트림은%20주의해서%20사용하라/thumbnail.jpg
---

## 스트림 API

[스트림 API](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/stream/package-summary.html)는 Java 8부터 추가된 기능으로, 데이터의 흐름을 추상화해서 다루는 도구이다. 스트림은 스트림의 생성, 중간 연산(Intermediate Operation), 종단 연산(Terminal Operation)의 흐름을 가진다. 중간 연산은 데이터를 걸러내거나 형태를 변환하며, 종단 연산을 통해 최종 결과를 모으거나 실행할 수 있다.

스트림을 활용하면 다양한 중간 연산과 종단 연산을 통해 복잡한 데이터 처리 로직도 간단하며 선언적으로 구현할 수 있다.

아래는 과일들이 들어있는 리스트에 대해 알파벳 `B`로 시작하는 과일을 대문자로 변환하여 출력하는 예시다.

```java
public class StreamMain1 {
    public static void main(String[] args) {
        List<String> names = List.of("Apple", "Banana", "Berry", "Tomato");

        // 스트림의 생성
        Stream<String> stream = names.stream();

        // 중간 연산과 종단 연산
        stream
                .filter(name -> name.startsWith("B"))  // 중간 연산
                .map(name -> name.toUpperCase())  // 중간 연산
                .forEach(name -> System.out.println(name));  // 종단 연산

        // 출력 결과
        // BANANA
        // BERRY
    }
}
```

주어진 과일 리스트에 대해 `filter()`로 알파벳 `B`로 시작하지 않는 과일을 거르고, `map()`으로 과일을 대문자로 변환하며 `forEach()`로 순회하며 결과를 출력하고 있다. 스트림의 중간 연산들이 스트림을 다시 반환해서 메서드 체이닝을 통해 이어 쓸 수 있다. `Collection` 인터페이스가 `stream()` 메서드를 통해 스트림을 제공하고 있어서 `List`에서 스트림 API를 활용할 수 있다.

---

## 스트림의 특징

1. 원본 데이터를 변경하지 않음(Immutable)
   - 스트림에서 제공하는 연산들은 원본 데이터를 변경하지 않고 결과만 새로 생성
2. 일회성
   - 한 번 사용된 스트림은 다시 사용할 수 없으며, 필요하다면 새로 스트림을 생성해야 함
3. 파이프라인(Pipeline) 구성
   - 중간 연산들이 이어지다가, 종단 연산을 만나면 연산이 수행되고 종료됨
4. 지연 연산(Lazy Operation)
   - 중간 연산은 필요할 때까지 실제로 동작하지 않고, 종단 연산이 실행될 때 한번에 처리됨
5. 병렬 처리(Parallel) 용이
   - 스트림으로부터 병렬 스트림(Parallel Stream)을 쉽게 만들 수 있어서, 멀티코어 환경에서 병렬 연산을 비교적 단순한 코드로 작성할 수 있음

아래는 숫자로 이루어진 리스트에서 짝수만 모은 리스트를 스트림으로 생성하는 예시다.

```java
public class ImmutableMain {
    public static void main(String[] args) {
        List<Integer> originList = List.of(1, 2, 3, 4, 5);
        System.out.println("originList = " + originList);  // originList = [1, 2, 3, 4, 5]

        List<Integer> filteredList = originList.stream()
                .filter(n -> n % 2 == 0)
                .toList();
        System.out.println("filteredList = " + filteredList);  // filteredList = [2, 4]
        System.out.println("originList = " + originList);  // originList = [1, 2, 3, 4, 5]
    }
}
```

짝수 리스트 생성 후에도 원본 리스트는 변하지 않았다.

아래는 스트림에서 종단 연산인 `forEach()`를 두 번 실행하려한 예시로 `IllegalStateException`이 발생하며 스트림이 닫혔다는 문구가 나온다.

```java
public class DuplicateExceptionMain {
    public static void main(String[] args) {
        Stream<Integer> stream = Stream.of(1, 2, 3);

        stream.forEach(System.out::println);
        // 출력 결과
        // 1
        // 2
        // 3

        // IllegalStateException - stream has already been operated upon or closed
//        stream.forEach(System.out::println);
    }
}
```

아래는 숫자로 이루어진 리스트에서 홀수는 거르고 짝수는 10배를 한 결과를 리스트로 생성하는 예시다.

```java
public class LazyEvalMain1 {
    public static void main(String[] args) {
        List<Integer> list = List.of(1, 2, 3, 4, 5, 6);

        List<Integer> result = list.stream()
                .filter(i -> {
                    boolean isEven = i % 2 == 0;
                    System.out.println("filter() 실행: " + i + "(" + isEven + ")");
                    return isEven;
                })
                .map(i -> {
                    int mapped = i * 10;
                    System.out.println("map() 실행: " + i + "(" + mapped + ")");
                    return mapped;
                })
                .toList();

        System.out.println("result = " + result);  // result = [20, 40, 60]
    }
}
```

출력 결과는 아래와 같다.

```
filter() 실행: 1(false)
filter() 실행: 2(true)
map() 실행: 2(20)
filter() 실행: 3(false)
filter() 실행: 4(true)
map() 실행: 4(40)
filter() 실행: 5(false)
filter() 실행: 6(true)
map() 실행: 6(60)
```

`1, 2, 3, 4, 5, 6`에서 홀수를 거른 `2, 4, 6`이 생기고, 다시 10배를 한 `20, 40, 60`이 생기는 순서로 동작할 것 같지만 실제로 각각의 숫자가 `filter()` -> `map()` 순서로 흐르는 것을 볼 수 있다. 데이터 전체를 연산별로 한번에 처리하고 다음 연산으로 넘어가는 것을 일괄 처리(Batch Processing)라고 하며, 각 데이터가 연산을 통과하듯이 이루어지는 것을 파이프라인 처리(Pipeline Processing)라고 한다.

아래는 기존 `LazyEvalMain2`에서 종단 연산인 `toList()`를 제거한 예시다.

```java
public class LazyEvalMain2 {
    public static void main(String[] args) {
        List<Integer> list = List.of(1, 2, 3, 4, 5, 6);

        list.stream()
                .filter(i -> {
                    boolean isEven = i % 2 == 0;
                    System.out.println("filter() 실행: " + i + "(" + isEven + ")");
                    return isEven;
                })
                .map(i -> {
                    int mapped = i * 10;
                    System.out.println("map() 실행: " + i + "(" + mapped + ")");
                    return mapped;
                });
    }
}
```

`main` 메서드를 실행하면 아무 것도 출력되지 않는데 스트림은 종단 연산이 수행될 때만 작동하는 지연 연산이 적용되어 있다. 중간 연산들은 어떤 동작에 대한 파이프라인만 설정되어 있고 실제 연산은 종단 연산이 호출되기 전에는 실행되지 않는다.

아래는 기존 `LazyEvalMain1`에서 `findFirst()`와 `get()`을 통해 첫 원소를 꺼내는 예시다.

```java
public class LazyEvalMain3 {
    public static void main(String[] args) {
        List<Integer> list = List.of(1, 2, 3, 4, 5, 6);

        Integer result = list.stream()
                .filter(i -> {
                    boolean isEven = i % 2 == 0;
                    System.out.println("filter() 실행: " + i + "(" + isEven + ")");
                    return isEven;
                })
                .map(i -> {
                    int mapped = i * 10;
                    System.out.println("map() 실행: " + i + "(" + mapped + ")");
                    return mapped;
                })
                .findFirst()
                .get();

        System.out.println("result = " + result);  // result = 20
    }
}
```

출력 결과는 아래와 같다.

```
filter() 실행: 1(false)
filter() 실행: 2(true)
map() 실행: 2(20)
```

`20`을 찾는 순간 다른 데이터에 대한 연산이 더 이루어지지 않고 종료되며 이를 통해 불필요한 연산을 하지 않는 최적화가 된다.(단축 평가, Short-Circuit)

---

## 스트림의 주의점

스트림을 사용하기 시작하면 모든 반복문을 스트림으로 바꾸고 싶은 유혹이 들 수 있지만 서두르면 안된다. 스트림으로 바꾸는게 가능할지라도 코드 가독성과 유지보수 측면에서 손해를 볼 수 있기 때문이다. 기존 코드를 스트림을 사용하도록 리팩토링 하되, 새 코드가 더 나아 보일 때만 반영하자.

아래는 교재 p.270의 예제로 주어진 단어의 애너그램 중 가장 사전순으로 빠른 단어를 key로 하고 해당 단어를 value의 TreeSet에 넣은 후 TreeSet의 크기가 최솟값 이상인 경우만 출력하는 예제다.

```java
public class Anagrams1 {
    public static void main(String[] args) throws FileNotFoundException {
        File dictionary = new File("./data/data.dat");
        int minGroupSize = 2;

        Map<String, Set<String>> groups = new HashMap<>();
        try (Scanner s = new Scanner(dictionary)) {
            while (s.hasNext()) {
                String word = s.next();

                // computeIfAbsent는 key가 있으면 값을 반환하고 key가 없으면 Function 실행
                groups.computeIfAbsent(alphabetize(word), (unused) -> new TreeSet<>()).add(word);
            }
        }

        // minGroupSize 이상인 그룹 출력
        for (Set<String> group : groups.values()) {
            if (group.size() >= minGroupSize) {
                System.out.println(group.size() + ": " + group);
            }
        }

        // 출력 결과
        // 3: [cdd, dcd, ddc]
        // 2: [aab, aba]
        // 3: [asdf, fasd, sadf]
    }

    // 문자열 s의 알파벳을 오름차순으로 정렬한 애너그램을 반환
    private static String alphabetize(String s) {
        char[] a = s.toCharArray();
        Arrays.sort(a);
        return new String(a);
    }
}
```

`compueIfAbset()` 메서드를 활용하여 가독성 좋게 로직을 구현한 것을 볼 수 있다.

아래는 동일한 로직에 과도한 스트림을 적용한 예시다.

```java
public class Anagrams2 {
    public static void main(String[] args) throws IOException {
        Path dictionary = Paths.get("./data/data.dat");
        int minGroupSize = 2;

        try (Stream<String> words = Files.lines(dictionary)) {
            words.collect(
                            groupingBy(word -> word.chars().sorted()
                                    .collect(StringBuilder::new,
                                            (sb, c) -> sb.append((char) c),
                                            StringBuilder::append).toString()))
                    .values().stream()
                    .filter(group -> group.size() >= minGroupSize)
                    .map(group -> group.size() + ": " + group)
                    .forEach(System.out::println);
        }

        // 출력 결과
        // 3: [cdd, ddc, dcd]
        // 2: [aab, aba]
        // 3: [asdf, fasd, sadf]
    }
}
```

결과는 동일하게 나왔지만 스트림을 활용한다고 가독성과 유지보수성이 올라갔다는 느낌은 없다.

---

## 김영한의 성능 피셜

성능의 경우 전통적인 for문이 보통 가장 빠르며 기본형 특화 스트림(`IntStream` 등)의 경우 보통 전통적인 for문과 비슷하거나 10 ~ 30% 정도 느리다고 한다. 일반 스트림의 경우 전통적인 for문 보다 보통 50 ~ 100% 정도 느리다고 한다. 하지만 극단적인 성능 향상이 필요한 경우가 아니면 성능적으로 큰 의미는 없으며 가독성, 유지보수성이 훨씬 중요한 판단 기준이라고 한다.

---
