---
title: "Programmers 148652 - 유사 칸토어 비트열"
date: 2024-10-29 15:00:00 +0900
categories: [Algorithm, Baekjoon]
tags: [문자열, 다이나믹 프로그래밍]
---

# [Programmers 148652 - 유사 칸토어 비트열](https://school.programmers.co.kr/learn/courses/30/lessons/148652)

## 김치

### 치즈

![](/assets/posts/2025-10-29/정보처리기사.jpg)

## 문제 설명

수학에서 칸토어 집합은 0과 1 사이의 실수로 이루어진 집합으로, [0, 1]부터 시작하여 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만들어집니다.

남아는 칸토어 집합을 조금 변형하여 유사 칸토어 비트열을 만들었습니다. 유사 칸토어 비트열은 다음과 같이 정의됩니다.

- 0 번째 유사 칸토어 비트열은 "1" 입니다.
- n(1 ≤ n) 번째 유사 칸토어 비트열은 n - 1 번째 유사 칸토어 비트열에서의 1을 11011로 치환하고 0을 00000로 치환하여 만듭니다.

남아는 `n` 번째 유사 칸토어 비트열에서 특정 구간 내의 1의 개수가 몇 개인지 궁금해졌습니다.
`n`과 1의 개수가 몇 개인지 알고 싶은 구간을 나타내는 `l`, `r`이 주어졌을 때 그 구간 내의 1의 개수를 return 하도록 solution 함수를 완성해주세요.

## 제한 사항

- 1 ≤ `n` ≤ 20
- 1 ≤ `l`, `r` ≤ 5ⁿ
  - `l` ≤ `r` < `l` + 10,000,000
  - `l`과 `r`은 비트열에서의 인덱스(1-base)이며 폐구간 `[l, r]`을 나타냅니다.

## 입출력 예

| n   | l   | r   | result |
| --- | --- | --- | ------ |
| 2   | 4   | 17  | 8      |

## 입출력 예 설명

2 번째 유사 칸토어 비트열은 "110`11110110000011`01111011" 입니다. 음영 표시된 부분은 폐구간 [4, 17] 이며 구간 내의 1은 8개 있습니다.

---

## 문제 정보

| 난이도 | Lv.2 |
| ------ | ---- |
| 정답률 | 24%  |

## 풀이 정보

| 풀이 시간 | 270 min                   |
| --------- | ------------------------- |
| 알고리즘  | 재귀, 다이나믹 프로그래밍 |

| 정확성 테스트                      |
| ---------------------------------- |
| 테스트 1 〉 통과 (0.04ms, 84.8MB)  |
| 테스트 2 〉 통과 (0.05ms, 86.3MB)  |
| 테스트 3 〉 통과 (0.04ms, 82.6MB)  |
| 테스트 4 〉 통과 (0.05ms, 90MB)    |
| 테스트 5 〉 통과 (0.05ms, 72.5MB)  |
| 테스트 6 〉 통과 (0.05ms, 80.3MB)  |
| 테스트 7 〉 통과 (0.05ms, 93.2MB)  |
| 테스트 8 〉 통과 (0.06ms, 88.7MB)  |
| 테스트 9 〉 통과 (0.06ms, 85.9MB)  |
| 테스트 10 〉 통과 (0.05ms, 82.7MB) |
| 테스트 11 〉 통과 (0.05ms, 88.9MB) |
| 테스트 12 〉 통과 (0.03ms, 92.7MB) |
| 테스트 13 〉 통과 (0.06ms, 80.1MB) |
| 테스트 14 〉 통과 (0.05ms, 94.5MB) |
| 테스트 15 〉 통과 (0.11ms, 81.1MB) |

## 코드

```java
class Solution {

    // n번째 유사 칸토어 비트열의 1의 개수를 저장하는 dp 배열
    private static final long[] dp = new long[1 + 20];

    // dp 배열 초기화
    static {
        dp[0] = 1L;
        for (int i = 1; i <= 20; i++) {
            dp[i] = dp[i - 1] * 4;
        }
    }

    public int solution(int n, long l, long r) {
        // 1 ~ r 구간에서 1 ~ l-1 구간의 1의 개수를 빼면 l ~ r 구간의 1의 개수가 됨
        return (int) (dfs(n, r - 1) - dfs(n, l - 2));
    }

    private static long dfs(int n, long range) {
        // range는 0 이상인 정수여야 유효한 범위
        if (range < 0) return 0;

        // 0번째 유사 칸토어 비트열까지 오면 어차피 1이 됨
        if (n == 0) return dp[0];

        // n이 하나 작은 유사 칸토어 비트열의 길이로 현재 유사 칸토어 비트열의 한 블록의 크기와 같음
        long size = (long) Math.pow(5, n - 1);

        // 블록 4개 이상을 차지할 경우 n이 하나 작은 유사 칸토어 비트열의 1의 개수 * 3 + 남은 구간 더하기
        if (range >= size * 4) {
            return dp[n - 1] * 3 + dfs(n - 1, range % size);
        }

        // 블록 3개 이상을 차지할 경우 n이 하나 작은 유사 칸토어 비트열의 1의 개수 * 2 + 남은 구간 더하기
        if (range >= size * 3) {
            return dp[n - 1] * 2 + dfs(n - 1, range % size);
        }

        // 블록 2개 이상을 차지할 경우 n이 하나 작은 유사 칸토어 비트열의 1의 개수 * 2
        if (range >= size * 2) {
            return dp[n - 1] * 2;
        }

        // 블록 1개 이상을 차지할 경우 n이 하나 작은 유사 칸토어 비트열의 1의 개수 + 남은 구간 더하기
        if (range >= size) {
            return dp[n - 1] + dfs(n - 1, range % size);
        }

        // 모두 해당하지 않으면 그냥 n이 하나 작은 유사 칸토어 비트열에서 계산
        return dfs(n - 1, range % size);
    }
}
```

## 해설

재귀와 다이나믹 프로그래밍을 활용해서 해결했다. 유사 칸토어 비트열의 경우 `1`, `1 1 0 1 1`, `11011 11011 00000 11011 11011` 이런 식으로 이루어지는 비트열이며 특징으로 현재 비트열을 5등분 했을 때 1, 2, 4, 5번 비트열이 이전 비트열과 동일하고 3번 비트열은 전부 0으로 이루어졌다. 이를 활용하여 분할 정복을 적용할 수 있다. 주어진 구간에서 1의 개수를 구하는 것은 1부터 `r` 구간의 1의 개수에서 1부터 `l - 1` 구간의 1의 개수를 빼면 구할 수 있다. 이를 위해 1부터 `range` 까지의 1의 개수를 구하는 메서드를 통해 한번에 구했다. 다이나믹 프로그래밍을 적용하면 먼저 `n`에 대한 유사 칸토어 비트열의 전체 1의 개수를 배열로 미리 저장했다. 이후 주어진 범위에 대해 5등분 중 몇 개의 구간을 포함하는지를 기준으로 반환 값을 설정해주면 됐다. 모듈러 연산의 편의를 위해 첫번재 인덱스를 0으로 생각하고 계산하였다.

## 리뷰

나눗셈과 모듈러 연산에서 계속 디버깅이 안돼서 시간이 엄청 오래 걸리다가 인터넷을 참고했는데 두 구간의 차로 주어진 구간을 구한다는 아이디어를 활용했다. 레벨에 비하면 문제가 꽤 어려운 편인거 같다.

---
