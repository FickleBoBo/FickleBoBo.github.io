---
title: "[백준] 1316번 - 그룹 단어 체커 [Java][C++]"
date: 2025-12-05
categories: [PS, BaekJoon]
tags: [구현, 문자열]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/1316)

---

## 1. 문제 풀이

문자열에서 한 번 등장한 문자가 연속되지 않은 곳에서 다시 등장하지 않아야 그룹 단어가 된다. 문자열의 각 문자에 대해 방문 체크를 하고 현재 문자를 방문한 적이 있을 때, 이전 문자가 현재 문자와 동일하지 않다면 그룹 단어가 아니다.

---

## 2. 코드

### 1. 구현 [Java]

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        int cnt = 0;

        out:
        for (int i = 0; i < N; i++) {
            String str = br.readLine();
            boolean[] visited = new boolean[26];
            char prev = '\u0000';

            for (char c : str.toCharArray()) {
                if (visited[c - 'a'] && c != prev) continue out;

                visited[c - 'a'] = true;
                prev = c;
            }

            cnt++;
        }

        System.out.println(cnt);
    }
}
```

### 2. 구현 [C++]

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;

    int cnt = 0;

    for (int i = 0; i < n; i++) {
        string s;
        cin >> s;

        bool visited[26] = {};
        char prev = '\0';
        bool flag = true;

        for (char c : s) {
            if (visited[c - 'a'] && c != prev) {
                flag = false;
                break;
            }

            visited[c - 'a'] = true;
            prev = c;
        }

        if (flag) cnt++;
    }

    cout << cnt;
}
```

---

## 3. 풀이 정보

### 1. 구현 [Java]

| 언어    | 시간   | 메모리   | 코드 길이 |
| ------- | ------ | -------- | --------- |
| Java 11 | 112 ms | 14160 KB | 698 B     |

### 2. 구현 [C++]

| 언어   | 시간 | 메모리  | 코드 길이 |
| ------ | ---- | ------- | --------- |
| C++ 17 | 0 ms | 2024 KB | 580 B     |

---
