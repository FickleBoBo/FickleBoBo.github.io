---
title: "[백준] 17218번 - 비밀번호 만들기 [Java]"
date: 2025-11-05
categories: [알고리즘, 백준]
tags: [문자열, 다이나믹 프로그래밍, LCS, 투 포인터 알고리즘, 역추적]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/17218)

![](/assets/posts/2025-11/백준%2017218%20비밀번호%20만들기/photo1.png)
![](/assets/posts/2025-11/백준%2017218%20비밀번호%20만들기/photo2.png)

---

## 문제 풀이

두 문자열에서 공통으로 존재하는 가장 긴 부분 문자열을 구하는 문제로 LCS를 구해야 하는 문제다. 다만 LCS의 길이가 아니라 실제 부분 문자열을 구해야 한다는 점에서 다이나믹 프로그래밍을 활용해 LCS를 구한 후 역추적을 통해 실제 문자열 정보를 얻어야 한다.

---

## 코드

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        char[] str1 = br.readLine().toCharArray();
        char[] str2 = br.readLine().toCharArray();
        int N = str1.length;
        int M = str2.length;

        int[][] dp = new int[1 + N][1 + M];
        for (int i = 1; i <= N; i++) {
            for (int j = 1; j <= M; j++) {
                if (str1[i - 1] == str2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }

        System.out.println(backtrace(str1, str2, N, M, dp));
    }

    // 역추적
    private static String backtrace(char[] str1, char[] str2, int N, int M, int[][] dp) {
        StringBuilder sb = new StringBuilder();

        int r = N - 1;
        int c = M - 1;

        while (r >= 0 && c >= 0) {
            if (str1[r] == str2[c]) {
                sb.append(str1[r]);
                r--;
                c--;
            } else {
                if (dp[r][c + 1] > dp[r + 1][c]) {
                    r--;
                } else {
                    c--;
                }
            }
        }

        return sb.reverse().toString();
    }
}
```

---

## 풀이 정보

- 11 min

![](/assets/posts/2025-11/백준%2017218%20비밀번호%20만들기/photo3.png)

---

## 리뷰

dp 배열을 통한 LCS 역추적에 대해 알고 있으면 간단하게 해결할 수 있는 문제였다.

---
