---
title: "[백준] 1094번 - 막대기 [Java]"
date: 2025-10-31
categories: [알고리즘, 백준]
tags: [수학, 비트마스킹]
toc: true
math: true
---

[문제 링크](https://www.acmicpc.net/problem/1541)

![](/assets/posts/2025-10/2025-10-31/백준%201094%20막대기/photo1.png)
![](/assets/posts/2025-10/2025-10-31/백준%201094%20막대기/photo2.png)

---

## 문제 풀이

길이 `64`인 막대기를 가지고 길이 `X`인 막대기를 만들어야 하는데 현재 가지고 있는 막대기의 길이의 합이 `X`보다 크면 가지고 있는 막대기 중 길이가 가장 짧은 것을 절반으로 자르고, 자른 막대기 중 하나를 버리고 남은 막대기의 길이의 합이 `X`보다 크거나 같다면 자른 막대기 중 하나를 버리는 과정을 반복한다. 이때 길이 `X`인 막대기를 만들 수 있을 때 막대기의 수를 구해야 한다.

예제 입력 1을 예로 들면 길이 `64`인 막대기로 길이 `23`인 막대기를 만들어야 하는데 길이 `64`인 막대기를 절반으로 잘라 길이 `32`인 막대기 두 개로 만든다. 이때 자른 막대기 중 하나를 버리고 남아 있는 막대기의 길이의 합인 `32`가 `23`보다 크므로 `32`인 막대기는 버린다. 현재 길이 `32`인 막대기 하나만 가지고 있다.

이제 길이 `32`인 막대기가 `23`보다 크므로 다시 막대기를 절반으로 잘라 길이 `16`인 막대기 두 개로 만든다. 이때 자른 막대기 중 하나를 버리고 남아 있는 막대기의 길이의 합인 `16`이 `23`보다 작으므로 버리지 않는다. 현재 길이 `16`인 막대기 두 개를 가지고 있다.

이제 길이 `16`인 막대기 하나를 절반으로 잘라 길이 `8`인 막대기 두 개로 만든다. 이때 자른 막대기 중 하나를 버리고 남아 있는 막대기의 길이의 합인 `16+8=24`가 `23`보다 크므로 길이 `8`인 막대기 하나를 버린다. 현재 길이 `16`, `8`인 막대기를 가지고 있다.

이제 가지고 있는 막대기 중 길이가 가장 짧은 길이 `8`의 막대기를 절반으로 잘라 길이 `4`인 막대기 두 개로 만든다. 이때 자른 막대기 중 하나를 버리고 남아 있는 막대기의 길이의 합인 `16+4=20`이 `23`보다 작으므로 버리지 않는다. 현재 길이 `16`인 막대기 하나, 길이 `4`인 막대기 두 개를 가지고 있다.

이제 가지고 있는 막대기 중 길이가 가장 짧은 길이 `4`의 막대기를 절반으로 잘라 길이 `2`인 막대기 두 개로 만든다. 이때 자른 막대기 중 하나를 버리고 남아 있는 막대기의 길이의 합인 `16+4+2=22`가 `23`보다 작으므로 버리지 않는다. 현재 길이 `16`인 막대기 하나, 길이 `4`인 막대기 하나, 길이 `2`인 막대기 두 개를 가지고 있다.

이제 가지고 있는 막대기 중 길이가 가장 짧은 길이 `2`의 막대기를 절반으로 잘라 길이 `1`의 막대기 두 개로 만든다. 이때 자른 막대기 중 하나를 버리고 남아 있는 막대기의 길이의 합인 `16+4+2+1=23`이 `23`과 일치하므로 `4`개의 막대기로 길이 `23`의 막대기를 만들 수 있다.

결과를 보면 알 수 있듯이 `X`를 2의 제곱수들의 합으로 표현했을 때 수의 개수와 일치하는 것을 알 수 있다. 이는 `X`를 2로 나눈 나머지를 활용한 방식과 비트마스킹을 활용한 방식, `bitCount()` 메서드를 활용한 방식 등 다양하게 구할 수 있다.

---

## 코드

### 모둘러 연산을 활용한 방식

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int X = Integer.parseInt(br.readLine());
        int cnt = 0;

        while (X > 0) {
            if (X % 2 == 1) {
                cnt++;
            }

            X /= 2;
        }

        System.out.println(cnt);
    }
}
```

### 비트마스킹을 활용한 방식

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int X = Integer.parseInt(br.readLine());
        int cnt = 0;

        for (int bit = 1; bit <= X; bit <<= 1) {
            if ((X & bit) > 0) {
                cnt++;
            }
        }

        System.out.println(cnt);
    }
}
```

### bitCount() 메서드를 활용한 방식

```java
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int X = Integer.parseInt(br.readLine());

        System.out.println(Integer.bitCount(X));
    }
}
```

---

## 풀이 정보

### 모둘러 연산을 활용한 방식

- 3 min

![](/assets/posts/2025-10/2025-10-31/백준%201094%20막대기/photo3.png)

### 비트마스킹을 활용한 방식

- 8min

![](/assets/posts/2025-10/2025-10-31/백준%201094%20막대기/photo4.png)

### bitCount() 메서드를 활용한 방식

- 2min

![](/assets/posts/2025-10/2025-10-31/백준%201094%20막대기/photo5.png)

---

## 리뷰

문제 설명이 약간 가독성이 안 좋았던 것 같다.

---
